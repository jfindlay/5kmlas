#!/usr/bin/env python
# 5kmlas_ctl - run 5 km laser calibration system for Middle Drum fluorescence detector
# Wed Feb 16 16:05:00 MST 2011
# findlay@cosmic.utah.edu

# TODO:
# - develop rigorous and thorough hardware failure simulation routine
# - remote capture of data should happen during calibration run since Middle
#   Drum operates off-grid, therefore, discontinuously
# - create unprivileged user to run 5kmlas_ctl runner/calibrator
# - mount rootfs on SBC readonly in chrooted or pivot_rooted USB system
# - mount root of USB system readonly
# - ensure cron is started in USB system during bootup
# - sync system clock with Middle Drum at the beginning of each run (or just first run of the night)
# - make 65536 default SerialDevice buffer size and change buffer size to a kw argument

# A module is a discrete, active component of the 5kmlas system.  It consists
# of either a physical unit and a corresponding python class/object singleton or
# just the python class/object.
#
# list of modules in the hierarchy of program control:
# - control: logical module.  Functions like a control panel.  All other
#   modules connect with the control module in unified manner.  Provides
#   failsafe auto shutdown functionality
#   * data: logical module.  Stores data in memory, writes it to /tmp/data and
#     then /mnt/data
#   * charger: regulates electrical energy supply and use among the solar
#     array, battery array, and other modules.
#   * PTH: measures environmental state, controls the power states of other modules
#     - rain: measures rain state: dry,wet,open/none
#     - heater: heats laser exit window
#     - inverter: converts battery DC supply current to AC
#   * RPC: controls power states of AC modules
#     - radiometer: measures laser intensity
#     - shutter: opens and closes laser exit port
#     - laser: source of Middle Drum calibration radiation
# modules which are always powered on, or in constant use:
#   SBC, PTH, radio, antenna, charger, batteries, solar array
# modules powered on by SBC controlling program:
#   rain sensor, heater, inverter, RPC, radiometer, shutter, laser

import os,sys,re,gzip,datetime # datetime.datetime object can't be imported
                               # directly because datetime's __repr__
                               # assumptions will cause errors when eval-ing
                               # written data
from subprocess import call
from time import sleep
from datetime import timedelta,tzinfo,time
from optparse import OptionParser,OptionGroup
from pprint import saferepr,isreadable
from serial import Serial,SerialException,SerialTimeoutException
from pymodbus.client.sync import ModbusSerialClient as ModbusClient
from pymodbus.mei_message import ReadDeviceInformationRequest
from pymodbus.exceptions import ModbusException

# data #########################################################################

class Enum:
  # this idiom is from http://norvig.com/python-iaq.html.  It might be better
  # to use collections.namedtuple, but this datatype wasn't added to python
  # until 2.6 and I would have to upgrade debian to squeeze, which uses the new
  # ARM ABI
  '''
  Create an enumerated type, then add var/value pairs to it.
  The constructor and the method .ints(names) take a list of variable names,
  and assign them consecutive integers as values.  The method .strs(names)
  assigns each variable name to itself (that is variable 'v' has value 'v').
  The method .vals(a=99, b=200) allows you to assign any value to variables.
  A 'list of variable names' can also be a string, which will be .split().
  The method .end() returns one more than the maximum int value.

  Example: opcodes = Enum('add sub load store').vals(illegal=255).
  '''

  def __init__(self,names=[]) : self.ints(names)

  def set(self,var,val):
    '''Set var to the value val in the enum.'''
    if var in vars(self).keys() : raise AttributeError('duplicate var in enum')
    if val in vars(self).values() : raise ValueError('duplicate value in enum')
    vars(self)[var] = val
    return self

  def strs(self,names):
    '''Set each of the names to itself (as a string) in the enum.'''
    for var in self._parse(names) : self.set(var,var)
    return self

  def ints(self,names):
    '''Set each of the names to the next highest int in the enum.'''
    for var in self._parse(names) : self.set(var,self.end())
    return self

  def vals(self,**entries):
    '''Set each of var=val pairs in the enum.'''
    for (var,val) in entries.items() : self.set(var,val)
    return self

  def end(self):
    '''One more than the largest int value in the enum, or 0 if none.'''
    try : return max([x for x in vars(self).values() if type(x)==type(0)]) + 1
    except ValueError : return 0

  def lookup(self,num):
    '''Lookup enum value by number.'''
    d = dict((v,k) for k, v in vars(self).iteritems())
    return d[num]

  def _parse(self,names):
    '''If names is a string, parse it as a list of names.'''
    if type(names) == type('') : return names.split()
    else : return names

verbosity = Enum('quiet normal verbose') # message verbosity
phase = Enum('undefined init collect final') # phase
# hardware states
power_state = Enum('undefined on off')
conf_state = Enum('undefined initialized finalized error')
rain_state = Enum('undefined dry wet open')
# serial states
communication_state = Enum('undefined success error timeout')
# run modes
run_mode = Enum('run darkbox calibrate poll store')

class UTC(tzinfo): # for some reason, I have to implement UTC
  '''identity timezone'''
  def __init__(self) : super(UTC,self).__init__()
  def __str__(self) : return 'UTC'
  def __repr__(self) : return 'UTC()'
  def tzname(self,dt) : return self.__str__()
  def utcoffset(self,dt) : return timedelta(0)
  def dst(self,dt) : return timedelta(0)

class Data:
  '''
  Data events are written to self.temp_file where they are buffered until
  written to self.store_dir.  Data is written to files in self.store_dir with
  one file per UTC day.  Each event datum is written in chronological order to
  the storage file that matches its timestamp.
  '''

  def __init__(self):
    self.temp_file = '/tmp/data' # location of temporary data storage file
    self.store_dir = '/tmp/store' # location of data storage files
    self._ensure_paths()         # ensure self.temp_file and self.store_dir
    self.temp_names = []         # list of the names of temporary files
    self.store_files = {}        # dictionary of storage files
    self.temp_buffer = []        # buffer of data to be written into self.tmp datum files
    self.store_buffer = []       # buffer of data to be written into self.store_dir day files
    self.gzip_level = 9          # gzip compression level
    self.zero_datetime = datetime.datetime.utcfromtimestamp(0) # 1970-01-01 00:00:00.000000 UTC
    self.zero_time = time(0,0,0,0,UTC()) # 00:00:00.000000 UTC

  def __del__(self):
    '''
    try to save the data
    '''
    try : self.write()
    except : pass

  def append(self,**kwargs):
    '''
    collect datum kwargs into data buffer
    '''
    for kwarg in kwargs:
      self.temp_buffer.append(kwargs[kwarg])

  def write(self):
    '''
    write data to temporary storage location
    '''
    if len(self.temp_buffer) > 0:
      self.temp_buffer.sort(key=lambda datum : datum['timestamp']) # sort data by timestamp
      f = open(self.temp_file,'a')        # open file
      for datum in self.temp_buffer:
        f.write('%s\n' % saferepr(datum)) # write datum
      f.close()                           # close file
      del self.temp_buffer[:]             # clear data buffer

  def store(self):
    '''
    collate data from the temporary data files into one gzipped DST file per
    UTC day in self.store_dir and delete temporary data files once they've been
    collected into the corresponding day file
    '''
    # TODO: write data in DST 5kmlas bank format
    temp_f = open(self.temp_file,'r')        # open temp data file
    for line in temp_f:                      # read temp file contents into self.store_buffer
      if isreadable(line) and len(line) > 0: # check readability of file contents
        self.store_buffer.append(eval(line)) # append contents to store_buffer
      else:
        raise SyntaxError('Cannot eval() datum, %s.' % line)
    self.store_buffer.sort(key=lambda datum : datum['timestamp']) # sort data by timestamp
    for datum in self.store_buffer:
      date = datum['timestamp'].date()                       # date of datum
      if not date in self.store_files.keys():                # get corresponding day file
        self.store_files[date] = self._get_store_file(date)  # current day file
      self.store_files[date].write('%s\n' % saferepr(datum)) # write datum
    for date in self.store_files.keys():
      self.store_files[date].close()                         # close file objects
    del self.store_buffer[:]                                 # clear store buffer
    temp_f.close()                                           # close temp data file
    os.remove(self.temp_file)                                # remove temp data file

  def rsync(self):
    '''
    rsync self.store_dir files during calibrator process and remove old data
    files in self.store_dir
    '''
    # TODO: the calibration run user should probably do this manually.  The SBC
    # has a DHCP server and I can serve the files over HTTP
    for f in self.store_files:
      call(('/usr/bin/rsync','-q',self.store_dir,'tamember@<computer_name_here>:</path/to/rsync/dir/here/>'))

  def _ensure_paths(self):
    '''
    ensure that self.temp_file exists and is a file and self.store_dir exist and is a directory
    '''
    if not os.path.exists(self.temp_file):
      f = open(self.temp_file,'w') ; f.close()
    if os.path.exists(self.temp_file) and not os.path.isfile(self.temp_file):
      raise OSError('Data temporary storage location, %s, is not a file.' % self.temp_file)
    if not os.path.exists(self.store_dir):
      os.makedirs(self.store_dir)
    if not os.path.isdir(self.store_dir):
      raise OSError('Data storage location, %s, is not a directory.' % self.store_dir)

  def _get_store_file(self,date):
    '''
    open one gzipped storage file per the UTC day.  The particular files opened
    and used are determined by the timestamps of the data to be written
    '''
    f_name = os.path.join(self.store_dir,'%s.gz' % date)      # file name
    if os.path.exists(f_name) and not os.path.isfile(f_name): # file exists and is not a regular file
      raise OSError('Data storage file, %s, is not a regular file.' % f_name)
    else:
      return gzip.open(f_name,'a',self.gzip_level)            # open as gzipped file

# module abstract base classes #################################################

class SerialModule(Serial):
  '''
  abstract base class for serial modules

  This class provides error handling for initializing, reading, and writing
  serial devices.  If an exception is raised by pyserial, a serial module flag
  is set and then handled by the control module.
  '''

  def __init__(self,buffer_size,*args,**kwargs):
    self.buffer_size = buffer_size
    self.communication_state = communication_state.undefined
    try:
      super(SerialModule,self).__init__(*args,**kwargs)
    except SerialException,serial_exception:
      self.conf_state = conf_state.error
      self.message = 'failed to initialize %s serial connection: %s' % (self.name,serial_exception)
      return

  def read(self):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).read(self.buffer_size).strip() # strip padding whitespace
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to read from serial device %s: %s' % (self.name,serial_exception)
      return '' # classes derived from SerialModule always expect a return value of str type
    except SerialTimeoutException,timeout_exception:
      self.communication_state = communication_state.timeout
      self.message = 'failed to read from serial device %s: %s' % (self.name,timeout_exception)
      return ''

  def write(self,data):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).write(data)
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to write to serial device %s: %s' % (self.name,serial_exception)
      return
    except SerialTimeoutException,timeout_exception:
      self.communication_state = communication_state.timeout
      self.message = 'failed to write to serial device %s: %s' % (self.name,timeout_exception)
      return

class ModbusModule(ModbusClient):
  '''
  abstract base class for modbus modules.  Modbus is a protocol that can run on
  top of serial,TCP,UDP.  ModbusClient contains a pySerial interface
  '''

  def __init__(self,*args,**kwargs):
    self.communication_state = communication_state.undefined
    try:
      super(ModbusModule,self).__init__(*args,**kwargs)
    except ModbusException,modbus_exception:
      self.conf_state = conf_state.error
      self.message = 'failed to initialize %s modbus connection: %s' % (self.name,serial_exception)
      return

  def read_device_identification(self,address,count=1,unit=0x00):
    '''
    this method is not defined in pymodbus
    '''
    request = ReadDeviceInformationRequest(address,count)
    return request.decode(self.execute(request.encode()))

  # TODO: overload modbus methods and catch modbus errors here
  # try: except ModbusException:

class PowerModule(object):
  '''
  abstract base class for power modules
  '''

  def __init__(self):
    pass

# module classes ###############################################################

class Charger(ModbusModule):
  '''
  charge controller module
  '''
  def __init__(self):
    self.name = 'charge controller'   # charger module name
    self.conf_message = ''            # state message
    self.message = ''                 # result message
    self._define_enums()
    self._define_bitfields()
    super(Charger,self).__init__(method='rtu',port='/dev/tts/1',baudrate=9600,bytesize=8,parity='N',stopbits=2,timeout=1.5,writeTimeout=1.5)
    self.set_conf_state()

  def set_conf_state(self): # TODO: read vendor name, etc.
    self.conf_state = conf_state.initialized # module conf state

  def poll_data(self):
    registers = self.read_holding_registers(0x0000,0x0035,unit=0x01).registers
    data_dict = self._structure_data(registers)
    self._convert_enums_bitfields(data_dict)
    return data_dict

  def _define_enums(self):
    self.enums = {}
    self.enums['charge state'] = Enum().vals(
        START      =0,
        NIGHT_CHECK=1,
        DISCONNECT =2,
        NIGHT      =3,
        FAULT      =4,
        BULK_CHARGE=5,
        ABSORPTION =6,
        FLOAT      =7,
        EQUALIZE   =8)
    self.enums['load state'] = Enum().vals(
        START      =0,
        LOAD_ON    =1,
        LVD_WARNING=2,
        LVD        =3,
        FAULT      =4,
        DISCONNECT =5)
    self.enums['LED state'] = Enum().vals(
        LED_START                 =0,
        LED_START2                =1,
        LED_BRANCH                =2,
        EQUALIZE_FAST_GREEN_BLINK =3,
        FLOAT_SLOW_GREEN_BLINK    =4,
        ABSORPTION_GREEN_BLINK_1HZ=5,
        GREEN_LED                 =6,
        UNDEFINED_7               =7,
        YELLOW_LED                =8,
        UNDEFINED_9               =9,
        BLINK_RED_LED             =10,
        RED_LED                   =11,
        R_Y_G_ERROR               =12,
        RY_G_ERROR                =13,
        RG_Y_ERROR                =14,
        R_Y_ERROR_HTD             =15,
        R_G_ERROR_HVD             =16,
        RY_GY_ERROR               =17,
        GYR_ERROR                 =18,
        GYR_x_2                   =19)

  def _define_bitfields(self):
    self.bitfields = {}
    #    state                                         bit
    self.bitfields['array fault'] = [
        'overcurrent',                               # 0
        'FETs shorted',                              # 1
        'software bug',                              # 2
        'battery HVD',                               # 3
        'array HVD',                                 # 4
        'EEPROM setting edit (reset required)',      # 5
        'RTS shorted',                               # 6
        'RTS was valid, now disconnected',           # 7
        'local temp. sensor failed',                 # 8
        'Fault 10',                                  # 9
        'Fault 11',                                  # 10
        'Fault 12',                                  # 11
        'Fault 13',                                  # 12
        'Fault 14',                                  # 13
        'Fault 15',                                  # 14
        'Fault 16']                                  # 15
    self.bitfields['load fault'] = [
        'external short circuit',                    # 0
        'overcurrent',                               # 1
        'FETs shorted',                              # 2
        'software bug',                              # 3
        'HVD',                                       # 4
        'heatsink over-temperature',                 # 5
        'EEPROM setting edit (reset required)',      # 6
        'Fault 8']                                   # 7
    self.bitfields['alarm'] = [
        'RTS open',                                  # 0
        'RTS shorted',                               # 1
        'RTS disconnected',                          # 2
        'Ths open',                                  # 3
        'Ths shorted',                               # 4
        'SSMPPT hot',                                # 5
        'Current limit',                             # 6
        'Current offset',                            # 7
        'Undefined',                                 # 8
        'Undefined',                                 # 9
        'Uncalibrated',                              # 10
        'RTS miswire',                               # 11
        'Undefined',                                 # 12
        'Undefined',                                 # 13
        'miswire',                                   # 14
        'FET open',                                  # 15
        'P12',                                       # 16
        'high Va current limit',                     # 17
        'Alarm 19',                                  # 18
        'Alarm 20',                                  # 19
        'Alarm 21',                                  # 20
        'Alarm 22',                                  # 21
        'Alarm 23',                                  # 22
        'Alarm 24']                                  # 23
    self.bitfields['dip switch'] = [
       # 1 value                              0 value                     function              bit
        'custom battery settings',          # User Select jumper          Battery Type          0
        'custom load settings',             # 11.5 V / 12.6 V             LVD / LVR             1
        'enabled (if battery type has EQ)', # disabled                    Equalize              2
        'MODBUS protocol']                  # Meterbus (MS remote meter)  Communication Select  3
    self.bitfields['daily array fault'] = self.bitfields['array fault']
    self.bitfields['daily load fault'] = self.bitfields['load fault']
    self.bitfields['daily alarm'] = self.bitfields['alarm']

  def _convert_enums_bitfields(self,data_dict):
    '''
    convert enums and bitfields into standard python types
    '''
    # convet enums
    for parameter in ('charge state','load state','LED state'):
      state = self.enums[parameter].lookup(data_dict[parameter][0])
      data_dict[parameter] = (state,'enum')
    # convert bitfields
    for parameter in ('array fault','load fault','alarm','dip switch','daily array fault','daily load fault','daily alarm'):
      state = []
      for offset in xrange(32): # 2**32 == 16**8, MPPT double register data values are 16**8 large
        if (data_dict[parameter][0] >> offset) & 1:
          state.append(self.bitfields[parameter][offset])
      data_dict[parameter] = (state,'bitfield')

  def _structure_data(self,registers):
    '''
    convert numerical data to standard units and structure charger data
    '''
    self.scale = { # scale factors
        'V':100.*2.**-15.,
        'V ref':96.667*2.**-15.,
        'A':79.16*2.**-15.,
        'W':989.*2.**-16.,
        'Ah':0.1,
        'kWh':0.1,
        'ratio':2.**-8.}
    data_dict = { # dict of tuples of measurements and associated units
        'type':                  'charger',                                     # type of data structure
        'timestamp':              datetime.datetime.now(UTC()),                 # [datetime object] Time stamp
        'battery volts':         (registers[0x0008]*self.scale['V'],'V'),       # [V] (tau = 1 s) Voltage measured directly at the battery connection on the SunSaver MPPT.
        'array volts':           (registers[0x0009]*self.scale['V'],'V'),       # [V] (tau = 1 s) Va is the terminal voltage of the solar input connection.
        'load volts':            (registers[0x000A]*self.scale['V'],'V'),       # [V] (tau = 1 s) Vl is the terminal voltage of the load output connection.
        'charging current':      (registers[0x000B]*self.scale['A'],'A'),       # [A] (tau = 1 s) Charging current to the battery as measured by on-board shunt.
        'load current':          (registers[0x000C]*self.scale['A'],'A'),       # [A] (tau = 1 s) Load current to the systems loads as measured by on-board shunt.
        'heatsink temp':         (registers[0x000D],'^oC'),                     # [^oC] Sunsaver MPPT Heatsink temperature.
        'battery temp':          (registers[0x000E],'^oC'),                     # [^oC] Battery temperature as measured by the ambient temperature sensor or the optional RTS (if connected).
        'ambient temp':          (registers[0x000F],'^oC'),                     # [^oC] Ambient temperature as measured by the ambient temperature sensor.
        # 0x0010, RTS is redundant
        'charge state':          (registers[0x0011],'enum'),                    # [enum] Reports the charge state.
        'array fault':           (registers[0x0012],'bitfield'),                # [bitfield] Reports faults identified by self diagnostics.
        'slow battery volts':    (registers[0x0013]*self.scale['V'],'V'),       # [V] (tau = 25 s) Voltage measured directly at the battery connection on the SunSaver MPPT.
        'battery ref':           (registers[0x0014]*self.scale['V ref'],'V'),   # [V] Target voltage to which the battery will be charged. This value is temperature compensated.
        'Ah resetable charge':  ((registers[0x0015]<<16 | registers[0x0016])*self.scale['Ah'],'Ah'), # [A*h] Reports total solar amp-hours since last ah reset.
        'Ah total charge':      ((registers[0x0017]<<16 | registers[0x0018])*self.scale['Ah'],'Ah'), # [A*h] Reports total solar amp-hours since last ah reset.
        'kWh charge':            (registers[0x0019]*self.scale['kWh'],'kWh'),   # [kW*h] Reports total solar kilowatt-hours since last ah/kWh reset.
        'load state':            (registers[0x001A],'enum'),                    # [enum] Reports the charge state.
        'load fault':            (registers[0x001B],'bitfield'),                # [bitfield] Reports faults identified by self diagnostics.
        'low disconnect volts':  (registers[0x001C]*self.scale['V'],'V'),       # [V] Low voltage disconnect setpoint, current compensated.
        'resetable load':       ((registers[0x001D]<<16 | registers[0x001E])*self.scale['Ah'],'Ah'), # [A*h] Reports total load amp-hours since last ah reset.
        'total load':           ((registers[0x001F]<<16 | registers[0x0020])*self.scale['Ah'],'Ah'), # [A*h] Reports total load amp-hours since last ah reset.
        'hour meter':            (registers[0x0021]<<16 | registers[0x0022],'h'), # [h] Reports total hours of operation since installed.
        'alarm':                 (registers[0x0023]<<16 | registers[0x0024],'bitfield'), # [bitfield] Reports alarms identified by self diagnostics. Each bit corresponds to a specific alarm.
        'dip switch':            (registers[0x0025],'bitfield'),                # [bitfield] Each bit in the bit-field corresponds to an individual DIP switch setting.
        'LED state':             (registers[0x0026],'enum'),                    # [enum] Reports the LED state.
        'power out':             (registers[0x0027]*self.scale['W'],'W'),       # [W] Output power to the battery.
        # sweep data is redundant, since the charger is regularly polled, but may be useful
        'sweep Vmp':             (registers[0x0028]*self.scale['V'],'V'),       # [V] Maximum power voltage of the solar array found during last sweep.
        'sweep Pmax':            (registers[0x0029]*self.scale['W'],'W'),       # [W] Maximum power output of the solar array found during last sweep.
        'sweep Voc':             (registers[0x002A]*self.scale['V'],'V'),       # [V] Open circuit voltage of the solar array found during last sweep.
        'daily Vb min':          (registers[0x002B]*self.scale['V'],'V'),       # [V] Minimum battery voltage measured today (value resets after dark).
        'daily Vb max':          (registers[0x002C]*self.scale['V'],'V'),       # [V] Maximum battery voltage measured today (value resets after dark).
        'daily Ah charge':       (registers[0x002D]*self.scale['Ah'],'Ah'),     # [A*h] Total charge amp-hours accumulated today (value resets after dark).
        'daily Ah load':         (registers[0x002E]*self.scale['Ah'],'Ah'),     # [A*h] Total load amp-hours accumulated today (value resets after dark).
        'daily array fault':     (registers[0x002F],'bitfield'),                # [bitfield] Reports array faults identified by self diagnostics that occurred today (value resets after dark).
        'daily load fault':      (registers[0x0030],'bitfield'),                # [bitfield] Reports load faults identified by self diagnostics that occurred today (value resets after dark).
        'daily alarm':           (registers[0x0031]<<16 | registers[0x0032],'bitfield'), # [bitfield] Reports alarms identified by self diagnostics that occurred today (value resets after dark).
        'min Vb':                (registers[0x0033]*self.scale['V'],'V'),       # [V] Tracks the minimum battery voltage over time (value resets after dark).
        'max Vb':                (registers[0x0034]*self.scale['V'],'V'),       # [V] Tracks the maximum battery voltage over time (value resets after dark).
        # There are further registers here, but they don't hold any data
        }
    return data_dict

class PTH(SerialModule):
  '''
  PTH module

  ?|HELP                  - help
  AIN [B|C|D|E]           - read inputs as analog (V)
  AMON [B|C|D|E] [<th>]   - set analog input threshold (V)
  AUTO [<sec>]            - set automatic readout period - 0 disables
  ECHO [0|1]              - serial echo - 0=disable 1=enable
  HEAT [0|1]              - set SHT11 heater - 0=off 1=on
  HUMID                   - read humidity (%RH)
  IN [A|B|C|D|E]          - read inputs as digital (0|1)
  OUT [A|B|C|D|E] [0|1]   - read [set] isolated output
  PRESS                   - read pressure (kPa)
  RAIN                    - read rain sensor dry|wet|open (D|W|X)
  RMON [0|1]              - set rain monitor enable
  SUPPLY                  - read supply voltage (V)
  TEMP                    - read temperture (degK)
  TENAB [0|1]             - set thermostat enable - 0 disables
  THIGH [<temp>]          - set cooler set point (output D)
  TLOW [<temp>]           - set heater set point (output E)
  VER                     - read device firmware version
  '''

  def __init__(self,*args,**kwargs):
    self.buffer_size = 65536 # = 2**2**2**2 : termios read buffer size
    self.name = 'PTH board'  # PTH module name
    self.conf_message = ''   # state message
    self.message = ''        # result message
    super(PTH,self).__init__(self.buffer_size,'/dev/ttyAM1',baudrate=9600,timeout=0.5,writeTimeout=0.5)
    self.read()              # clear output buffer
    self.write('ECHO 0\r\n') # disable PTH-side serial echo
    self.read()              # clear output buffer
    self.set_conf_state()

  def __del__(self):
    '''
    This is a redundant backup powerdown in the case that
    Control.auto_shutdown() is not called or completed.  All exceptions should
    be caught in main(), but if they aren't, then there is no guarantee that
    RPC.__del__() will be called before PTH.__del__().  This is only
    problematic because the RPC returns to the state it was in before it was
    powered off.
    '''
    try : self.off_all() # open all PTH switches
    except : pass

  def set_conf_state(self):
    '''
    set PTH configuration state
    '''
    self.read()                                   # clear output buffer
    self.write('VER\r\n')                         # check PTH initialized
    self.conf_message = self.read()               # read state message
    if re.search(r'VER\s+\S+',self.conf_message): # parse version message
      self.conf_state = conf_state.initialized    # module conf state
      self.message = 'PTH version: "%s"' % self.conf_message
    else:                                         # PTH did not print version message
      self.conf_state = conf_state.error
      self.message = 'PTH did not print version message.'
      self.message += '\nPTH output: "%s"' % self.conf_message

  def on(self,module=None):
    '''
    close a PTH switch
    '''
    self.read()                                  # clear output buffer
    self.write('%s\r\n' % module.PTH_on_command) # close PTH switch for module
    module.PTH_message = self.read()             # capture PTH message
    self.set_power_state(module=module)          # check module power on
    if module.power_state == power_state.on:     # if module powered on
      sleep(module.power_on_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                        # module failed to power on
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_on_command

  def off(self,module=None):
    '''
    open a PTH switch
    '''
    self.read()                                   # clear output buffer
    self.write('%s\r\n' % module.PTH_off_command) # open PTH switch for module
    module.PTH_message = self.read()              # capture PTH message
    self.set_power_state(module=module)           # check module power off
    if module.power_state == power_state.off:     # if module powered off
      sleep(module.power_off_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                         # module failed to power off
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_off_command

  def off_all(self):
    '''
    close all PTH switches without verification
    '''
    self.read()                            # clear output buffer
    self.write('RMON 0\r\n') ; self.read() # power off rain monitor
    self.write('HEAT 0\r\n') ; self.read() # power off heater
    self.write('OUT 0\r\n')  ; self.read() # power off all other switches

  def set_power_state(self,module=None):
    '''
    set power state of modules powered by PTH
    '''
    if re.search(r'%s' % module.PTH_on_command,module.PTH_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'%s' % module.PTH_off_command,module.PTH_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

  def poll_data(self):
    '''
    poll all PTH data
    '''
    self.read() # clear output buffer
    data_dict = {'type':'PTH','timestamp':datetime.datetime.now(UTC())}
    for name,unit in (('PRESS','Pa'),('TEMP','K'),('HUMID','%'),('RAIN','enum'),('SUPPLY','V')):
      self.write('%s\r\n' % name)
      message = self.read()
      if not self.communication_state == communication_state.error:
        measure = re.search(r'%s\s+(\S+)' % name,message).group(1)
        data_dict[name] = (measure,unit)
    return data_dict

  def poll_rain(self,module=None):
    '''
    poll PTH rain monitor state
    '''
    self.read() # clear output buffer
    self.write('RAIN\r\n')
    message = self.read() # read rain state
    if not self.communication_state == communication_state.error:
      trimmed_message = re.search(r'(RAIN\s+\S+)',message).group(1) # in open state, PTH repeats 'RAIN X' indefinitely
      module.PTH_message = trimmed_message
      rain_datum = re.split(r'\s+',module.PTH_message)
      self.set_rain_state(rain_datum[1],module=module)
    else:
      self.set_rain_state('',module=module)

  def set_rain_state(self,state,module=None):
    '''
    set rain state:
      'D' - dry (rain monitor resistance > 150 k\Omega)
      'W' - wet (rain monitor resistance < 150 k\Omega?)
      'X' - circuit open (rain monitor resistance -> \infty)
    '''
    if state == 'D': # dry
      module.rain_state = rain_state.dry
      module.message = 'no rain: "%s"' % module.PTH_message
    if state == 'W': # wet
      module.rain_state = rain_state.wet
      module.message = 'rain detected: "%s"' % module.PTH_message
    if state == 'X': # circuit open or no rain monitor
      module.rain_state = rain_state.open
      module.message = '%s circuit open or no %s present: "%s"' % (module.name,module.name,module.PTH_message)
    else: # undefined
      module.rain_state = rain_state.undefined
      module.message = '%s state undefined: "%s"' % (module.name,module.name,module.PTH_message)

class Rain(PowerModule):
  '''rain module'''

  def __init__(self):
    self.name = 'rain monitor'               # rain module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'RMON'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 5                  # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Heater(PowerModule):
  '''heater module'''

  def __init__(self):
    self.name = 'window heater'              # heater module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'HEAT'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 1 # 30             # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Inverter(PowerModule):
  '''inverter module'''

  def __init__(self):
    self.name = 'power inverter'             # inverter module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'A'                    # PTH board switch name
    self.PTH_on_command = 'OUT %s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = 'OUT %s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 10                 # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class RPC(SerialModule,PowerModule):
  '''
  RPC module

  RPC-2 Series
  (C) 1997 by BayTech
  F2.07

  Circuit Breaker: On

  1)...Outlet 1  : Off
  2)...Outlet 2  : Off
  3)...Outlet 3  : Off
  4)...Outlet 4  : Off
  5)...Outlet 5  : Off
  6)...Outlet 6  : Off
  '''

  def __init__(self):
    self.buffer_size = 65536 # = 2**2**2**2 : termios read buffer size
    self.name = 'RPC module' # RPC module name
    self.conf_message = ''   # state message
    self.message = ''        # result message
    # TODO: specify additional serial parameters
    super(RPC,self).__init__(self.buffer_size,'/dev/tts/2',baudrate=9600,timeout=1,writeTimeout=1)
    self.set_conf_state()

  def __del__(self):
    '''
    See comment in PTH.__del__().
    '''
    try : self.off_all() # power off all outlets
    except : pass

  def set_conf_state(self):
    '''
    set RPC module configuration state
    '''
    self.read()                                         # clear output buffer
    self.write('\r')                                    # prompt the RPC
    self.conf_message = self.read()                     # init message
    if re.search(r'Circuit Breaker',self.conf_message): # parse message for 'Circuit Breaker'
      self.conf_state = conf_state.initialized          # module conf state
      self.message = 'RPC initialized.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message
    else: # not a BayTech RPC, no RPC present, or if RPC prints out a message, the message doesn't contain 'Circuit Breaker'
      self.conf_state = conf_state.error
      self.message = 'RPC did not initialize.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message

  def on(self,module=None):
    '''
    power on a RPC outlet
    '''
    self.read()                               # clear output buffer
    self.write('ON %d\r' % module.RPC_outlet) # power on RPC outlet for module
    self.read()                               # clear output buffer
    self.write('Y\r')                         # confirm power on
    module.RPC_message = self.read()          # capture RPC message
    self.set_power_state(module=module)       # check powered on
    if module.power_state == power_state.on:  # if module powered on
      sleep(module.power_on_sleep)            # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                     # module failed to power on
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : On"' % (module.RPC_outlet,module.RPC_outlet)

  def off(self,module=None):
    '''
    power off a RPC outlet
    '''
    self.read()                                # clear output buffer
    self.write('OFF %d\r' % module.RPC_outlet) # power off RPC outlet for module
    self.read()                                # clear output buffer
    self.write('Y\r')                          # confirm power off
    module.RPC_message = self.read()           # capture RPC message
    self.set_power_state(module=module)        # check powered off
    if module.power_state == power_state.off:  # if module powered off
      sleep(module.power_off_sleep)            # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                      # module failed to power off
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : Off"' % (module.RPC_outlet,module.RPC_outlet)

  def off_all(self):
    '''
    power off all RPC outlets without verification
    '''
    self.read()         # clear output buffer
    self.write('OFF\r') # power off all RPC outlets
    self.read()         # clear output buffer
    self.write('Y\r')   # confirm power off
    self.read()         # clear output buffer

  def set_power_state(self,module=None):
    '''
    set power state of modules powered by RPC
    '''
    if re.search(r'^.*Outlet\s+%d\s+:\s+On.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'^.*Outlet\s+%d\s+:\s+Off.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

class Radiometer(SerialModule,PowerModule):
  '''
  radiometer module

  Auger CLF radiometer (RM-3700) settings from lwiencke:
  ID       Identity(3700)
  VR       Version
  TG 3     Trigger (0 internal, 3 external - positive edge)
  SS 0     Single shot (1 enable, 0 disable)
  FA 1.00  Calibration Factor Channel A - we use 1.00
  WA 335   Wavelength of laser(used to correct for Si probe response,)
  PA       Probe id and type (23 0 : 465 Si ), (2 0 : 734 pyro)
  EV 1     Event average       (should be 1)
  BS 0     In case this radiometer has batteries installed
  RA 4     Range  1,2,3:X,XX,XXX e-12 | 4,5,6:X,XX,XXX e-9 pJ
  ST       Return error status (should be 0)
  AD       ASCII Dump Mode
  '''

  def __init__(self):
    '''
    software init
    '''
    self.name = 'radiometer'                 # radiometer module name
    self.power_state = power_state.undefined # power state
    self.conf_state = conf_state.undefined   # configuration state
    self.RPC_outlet = 1                      # RPC outlet number
    self.power_on_sleep = 0                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.conf_message = ''                   # state message
    self.message = ''                        # result message

  def init(self):
    '''
    hardware init
    '''
    self.buffer_size = 65536 # = 2**2**2**2 : termios read buffer size
    # TODO: figure out how long read timeout needs to be to capture 5 m worth of radiometer data
    super(Radiometer,self).__init__(self.buffer_size,'/dev/tts/3',baudrate=9600,timeout=1.5,writeTimeout=1.5)
    self.write('TG 1\r') ; self.read() # internal trigger
    self.write('SS 0\r') ; self.read() # no single shot
    self.write('RA 2\r') ; self.read() # range 2: TODO: energy limits on this range?
    self.write('BS 0\r') ; self.read() # disable internal battery save
    self.set_conf_state()              # set configuration state
    self.write('AD\r')                 # setup ASCII dump mode

  def set_conf_state(self):
    self.read()                               # clear output buffer
    self.write('ST\r')                        # check error status
    self.conf_message = self.read()           # read message
    if re.search(r'[0-9]',self.conf_message): # if no errors, TODO: figure howto get status to 0 consistently
      self.conf_state = conf_state.initialized
      self.message = 'radiometer returned error status "0", no error'
    else:
      self.conf_state = conf_state.error
      self.message = 'radiometer returned error status "%s"' % self.conf_message

  def collect_datum(self):
    energies = []
    for i in re.split(r'\s+',self.read()):
      try: # only return the numbers from the radiometer message
        energies.append(float(i))
      except:
        pass
    data_dict = {'type':'radiometer','timestamp':datetime.datetime.now(UTC()),'energies':(energies,'J')}
    return data_dict

class Shutter(PowerModule):
  '''shutter module'''

  def __init__(self):
    self.name = 'shutter'                    # shutter module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 2                      # RPC outlet number
    self.power_on_sleep = 10                 # time to wait after power on
    self.power_off_sleep = 10                # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

class Laser(PowerModule):
  '''laser module'''

  def __init__(self):
    self.name = 'laser'                      # laser module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 3                      # RPC outlet number
    self.power_on_sleep = 2                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

# control module, operators ####################################################

class Log:
  '''
  provide printing functions and color printing
  '''
  def __init__(self):
    pass

  def init(self,opts):
    '''
    process program invocation settings
    '''
    if opts.verbose:                     # verbose output
      self.verbosity = verbosity.verbose
    if opts.normal:                      # normal output
      self.verbosity = verbosity.normal
    if opts.quiet:                       # no output except errors
      self.verbosity = verbosity.quiet
    if opts.color:                       # colorful output
      # modified from https://svn.blender.org/svnroot/bf-blender/trunk/blender/tools/bcolors.py
      self.CYAN   = '\033[96m'
      self.VIOLET = '\033[95m'
      self.BLUE   = '\033[94m'
      self.YELLOW = '\033[93m'
      self.GREEN  = '\033[92m'
      self.RED    = '\033[91m'
      self.GRAY   = '\033[90m'
      self.ENDC   = '\033[0m'
    else:
      self.CYAN   = ''
      self.VIOLET = ''
      self.BLUE   = ''
      self.YELLOW = ''
      self.GREEN  = ''
      self.RED    = ''
      self.GRAY   = ''
      self.ENDC   = ''

  def printf(self,data,color=''):
    '''
    write to sys.stdout
    '''
    if color : data = color + data + self.ENDC
    sys.stdout.write(data)
    sys.stdout.flush()

  def inform(self,data,color=''):
    '''
    write information to sys.stdout even in quiet mode
    '''
    self.printf(data,color=color)

  def report(self,data,color=''):
    '''
    write normal-level information to sys.stdout
    '''
    if self.verbosity > verbosity.quiet:
      self.printf(data,color=color)

  def detail(self,data,color=''):
    '''
    write verbose-level information to sys.stdout
    '''
    if self.verbosity == verbosity.verbose:
      self.printf(data,color=color)

log = Log()

class Control:
  '''
  software control module

  The control module wraps each serial/modbus communication to the physical
  modules in order to simplify and unify error traps.  Each call sets one or
  more associated states in the module.  The control module will take action
  upon each setting of state: either proceed normally or try to return the
  hardware and software to a well-defined and safe state.

  This scheme assumes at least three things:
  - The python code and the operating system it runs on are either so much more
    reliable in comparison with the hardware that they aren't worth checking or
    they will provide their own error handling when necessary.
  - The firmware on the hardware is so much more reliable than the hardware
    itself that all problems will originate with a hardware failure or
    misconfiguration and that the firmware will report it.
  - The hardware modules will fail only at the time of a state change or a
    serial read/write
  If the modbus module (charger) or any of the serial devices
  (PTH,RPC,radiometer) fail on the negotiation of the serial connection or when
  any data is sent/received to/from them, pymodbus/pyserial will handle and
  report those errors, which will be intercepted by the control module.

  The control process has three phases: init, collect, and final.  Depending on the
  phase and module, the control module may fail in a different manner.
  '''

  def __init__(self):
    self.phase = phase.undefined
    # create submodule stubs
    self.data = None
    self.charger = None
    self.PTH = None
    self.rain = None
    self.heater = None
    self.inverter = None
    self.RPC = None
    self.radiometer = None
    self.shutter = None
    self.laser = None
    # create list for modules that won't turn off
    self.modules_no_off = []

  # state checks
  def check_conf_state(self,desired_state,module=None):
    if module.conf_state == desired_state:
      log.report('done\n',color=log.GREEN)
      log.detail('%s\n' % module.message)
    elif module.conf_state == conf_state.undefined:
      log.inform('failed\n',color=log.RED)
      log.inform('%s\n' % module.message)
      self.auto_shutdown()
    elif module.conf_state == conf_state.error:
      log.inform('error\n',color=log.RED)
      log.inform('%s\n' % module.message)
      self.auto_shutdown()

  def check_power_state(self,desired_state,module=None):
    if module.power_state == desired_state:
      log.report('done\n',color=log.GREEN)
      log.detail('%s\n' % module.message)
    else:
      log.inform('failed\n',color=log.RED)
      log.inform('%s\n' % module.message)
      self.auto_shutdown(module_no_off=module)

  def check_rain_state(self,module=None):
    if module.rain_state == rain_state.dry:
        log.report('dry\n',color=log.GRAY)
        log.detail('%s\n' % module.message)
    elif module.rain_state == rain_state.wet:
      log.report('wet\n',color=log.BLUE)
      log.report('%s\n' % module.message)
      if self.phase != phase.final:
        self.auto_shutdown()
    elif module.rain_state == rain_state.open:
      log.report('open\n',color=log.YELLOW)
      log.report('%s\n' % module.message)
      if self.phase != phase.final:
        #self.auto_shutdown() # TODO: get rain sensor working
        self.off_rain()

  def check_communication_state(self,module=None):
    if module.communication_state == communication_state.success:
      return # serial module successfully written to or read from
    elif module.communication_state == communication_state.error:
      log.inform('error\n',color=log.RED)
      self.auto_shutdown()
    elif module.communication_state == communication_state.timeout:
      log.inform('timeout\n',color=log.RED)
      self.auto_shutdown()

  def auto_shutdown(self,module_no_off=None):
    '''
    To avoid an open loop, we will not try to power off any module that won't
    do so.
    '''
    if module_no_off:
      self.modules_no_off.append(module_no_off)
    self.verbosity = verbosity.verbose
    self.phase = phase.final
    log.inform('\nshutting down 5kmlas\n',color=log.RED)
    if self.laser and not self.laser in self.modules_no_off:
      if self.laser.power_state == power_state.on:
        self.off_laser() # power off if laser module is initialized, isn't a module that won't turn off, and is on
    if self.shutter and not self.shutter in self.modules_no_off:
      if self.shutter.power_state == power_state.on:
        self.off_shutter()
    if self.radiometer and not self.radiometer in self.modules_no_off:
      if self.radiometer.power_state == power_state.on:
        self.collect_radiometer_datum() # collect radiometer datum
        self.write_data()               # write all data
        self.off_radiometer()
    if self.inverter and not self.inverter in self.modules_no_off:
      if self.inverter.power_state == power_state.on:
        self.off_inverter()
    if self.heater and not self.heater in self.modules_no_off:
      if self.heater.power_state == power_state.on:
        self.off_heater()
    if self.rain and not self.rain in self.modules_no_off:
      if self.rain.power_state == power_state.on:
        self.off_rain()
    # TODO: perhaps set a flag on the SBC to not run again if there is a problem
    sys.exit(1) # system should now be in as safe of a state as possible

  # data commands
  def init_data(self):
    log.report('initializing data structure ... ')
    self.data = Data() # data structure
    log.report('done\n',color=log.GREEN)

  def set_start_time(self,start_time=None):
    log.detail('collecting run start time ... ')
    self.data.append(start_datum={'timestamp':start_time,'type':'start'})
    log.detail('done\n',color=log.GREEN)
    log.detail('%s\n' % start_time) # print start time when verbose

  def set_stop_time(self,stop_time=None):
    log.detail('collecting run stop time ... ')
    self.data.append(stop_datum={'timestamp':stop_time,'type':'stop'})
    log.detail('done\n',color=log.GREEN)
    log.detail('%s\n' % stop_time) # print stop time when verbose

  def write_data(self):
    if self.phase == phase.final:
      log.report('writing data ... ')
    else:
      log.detail('writing data ... ')
    self.data.write() # format and save data to temporary storage location
    # TODO: check write state
    if self.phase == phase.final:
      log.report('done\n',color=log.GREEN)
    else:
      log.detail('done\n',color=log.GREEN)

  def store_data(self):
    log.report('storing data ... ')
    self.data.store()               # store data to local data storage flash memory
    # TODO: check store state
    log.report('done\n',color=log.GREEN)

  def rsync_data(self):
    log.report('storing data ... ')
    self.data.rsync()
    # TODO: check rsync state
    log.report('done\n',color=log.GREEN)

  # charger commands
  def init_charger(self):
    log.report('initializing charger modbus interface ... ')
    self.charger = Charger()                                          # init charger
    self.check_communication_state(module=self.charger)               # check write state
    self.check_conf_state(conf_state.initialized,module=self.charger) # check charger init state

  def collect_charger_datum(self):
    log.detail('collecting charger datum ... ')
    charger_datum = self.charger.poll_data()
    self.check_communication_state(module=self.charger) # check write state
    self.data.append(charger_datum=charger_datum)       # append datum
    log.detail('done\n',color=log.GREEN)
    log.detail('%s\n' % charger_datum)                  # print charger datum when verbose

  def final_charger(self):
    log.report('finalizing charger modbus interface ... ')
    self.charger.close()                                   # final charger
    log.report('done\n',color=log.GREEN)

  # PTH commands
  def init_PTH(self):
    log.report('initializing PTH board ... ')
    self.PTH = PTH()                                              # init PTH board
    self.PTH.off_all()                                            # open all switches
    self.check_communication_state(module=self.PTH)               # check write state
    self.check_conf_state(conf_state.initialized,module=self.PTH) # check PTH init state

  def on_rain(self):
    log.report('powering on rain monitor ... ')
    self.rain = Rain()
    self.PTH.on(module=self.rain)                           # power on rain monitor module
    self.check_communication_state(module=self.PTH)         # check write state
    self.check_power_state(power_state.on,module=self.rain) # check rain monitor power state

  def off_rain(self):
    log.report('powering off rain monitor ... ')
    self.PTH.off(module=self.rain)                           # power off rain monitor module
    self.check_communication_state(module=self.PTH)          # check write state
    self.check_power_state(power_state.off,module=self.rain) # check rain monitor init state

  def on_heater(self):
    log.report('powering on heater ... ')
    self.heater = Heater()                                    # create object for heater module
    self.PTH.on(module=self.heater)                           # power on heater module
    self.check_communication_state(module=self.PTH)           # check write state
    self.check_power_state(power_state.on,module=self.heater) # check heater power state

  def off_heater(self):
    log.report('powering off heater ... ')
    self.PTH.off(module=self.heater)                           # power off heater module
    self.check_communication_state(module=self.PTH)            # check write state
    self.check_power_state(power_state.off,module=self.heater) # check heater power state

  def on_inverter(self):
    log.report('powering on inverter ... ')
    self.inverter = Inverter()                                  # create object for inverter module
    self.PTH.on(module=self.inverter)                           # power on inverter module
    self.check_communication_state(module=self.PTH)             # check write state
    self.check_power_state(power_state.on,module=self.inverter) # check inverter power state

  def off_inverter(self):
    log.report('powering off inverter ... ')
    self.PTH.off(module=self.inverter)                           # power off inverter module
    self.check_communication_state(module=self.PTH)              # check write state
    self.check_power_state(power_state.off,module=self.inverter) # check inverter power state

  def poll_rain(self):
    log.report('checking rain monitor ... ')
    self.PTH.poll_rain(module=self.rain)            # poll rain state
    self.check_communication_state(module=self.PTH) # check write state
    self.check_rain_state(module=self.rain)         # check rain state

  def collect_PTH_datum(self):
    log.detail('collecting PTH datum ... ')
    PTH_datum = self.PTH.poll_data()
    self.check_communication_state(module=self.PTH) # check write state
    self.data.append(PTH_datum=PTH_datum)           # append datum
    log.detail('done\n',color=log.GREEN)
    log.detail('%s\n' % PTH_datum)                  # print PTH datum when verbose

  def final_PTH(self):
    log.report('finalizing PTH board ... ')
    self.PTH.close()                        # final PTH
    log.report('done\n',color=log.GREEN)

  # RPC commands
  def init_RPC(self):
    log.report('initializing RPC module ... ')
    self.RPC = RPC()                                              # init RPC module
    self.RPC.off_all()                                            # power off all outlets
    self.check_communication_state(module=self.RPC)               # check write state
    self.check_conf_state(conf_state.initialized,module=self.RPC) # check RPC init state

  def on_radiometer(self):
    log.report('powering on radiometer ... ')
    self.radiometer = Radiometer()                                # create object for radiometer module
    self.RPC.on(module=self.radiometer)                           # power on radiometer module
    self.check_communication_state(module=self.RPC)               # check write state
    self.check_power_state(power_state.on,module=self.radiometer) # check radiometer power state

  def off_radiometer(self):
    log.report('powering off radiometer ... ')
    self.RPC.off(module=self.radiometer)                           # power off radiometer module
    self.check_communication_state(module=self.RPC)                # check write state
    self.check_power_state(power_state.off,module=self.radiometer) # check radiometer power state

  def on_shutter(self):
    log.report('opening shutter ... ')
    self.shutter = Shutter()                                   # create object for shutter module
    self.RPC.on(module=self.shutter)                           # power on shutter module
    self.check_communication_state(module=self.RPC)            # check write state
    self.check_power_state(power_state.on,module=self.shutter) # check shutter power state

  def off_shutter(self):
    log.report('closing shutter ... ')
    self.RPC.off(module=self.shutter)                           # power off shutter module
    self.check_communication_state(module=self.RPC)             # check write state
    self.check_power_state(power_state.off,module=self.shutter) # check shutter power state

  def on_laser(self):
    log.report('powering on laser ... ')
    self.laser = Laser()                                     # create object for laser module
    self.RPC.on(module=self.laser)                           # power on laser module
    self.check_communication_state(module=self.RPC)          # check write state
    self.check_power_state(power_state.on,module=self.laser) # check laser power state

  def off_laser(self):
    log.report('powering off laser ... ')
    self.RPC.off(module=self.laser)                           # power off laser
    self.check_communication_state(module=self.RPC)           # check write state
    self.check_power_state(power_state.off,module=self.laser) # check laser power state

  def final_RPC(self):
    log.report('finalizing RPC module ... ')
    self.RPC.close()                         # final RPC
    log.report('done\n',color=log.GREEN)

  # radiometer commands
  def init_radiometer(self):
    log.report('initializing radiometer ... ')
    self.radiometer.init()                                               # init radiometer module
    self.check_communication_state(module=self.radiometer)               # check write state
    self.check_conf_state(conf_state.initialized,module=self.radiometer) # check radiometer conf state

  def collect_radiometer_datum(self):
    log.report('collecting radiometer datum ... ')
    radiometer_datum = self.radiometer.collect_datum()     # read radiometer datum
    self.check_communication_state(module=self.radiometer) # check write state
    self.data.append(radiometer_datum=radiometer_datum)    # add datum to data
    log.report('done\n',color=log.GREEN)

  def final_radiometer(self):
    log.report('finalizing radiometer ... ')
    self.radiometer.close()                  # final radiometer
    log.report('done\n',color=log.GREEN)

class Operator(object):
  '''
  abstract base class for Daemon,Runner,Calibrator subclasses.  Provides common
  methods
  '''

  def __init__(self):
    pass

  def _list_proc_cmds(self):
    '''
    query the system for the invocations of all processes
    '''
    pids = [pid for pid in os.listdir('/proc') if pid.isdigit()]
    return [open(os.path.join('/proc',pid,'cmdline'),'rb').read() for pid in pids]

  def _find_instances(self):
    '''
    find instances of 5kmlas_ctl in system process list
    '''
    instances = {'poll':0,'store':0,'run':0}
    for cmd in self._list_proc_cmds():
      if re.search(r'5kmlas_ctl.*poll',cmd) :        instances['poll'] += 1
      elif re.search(r'5kmlas_ctl.*store',cmd) :     instances['store'] += 1
      elif re.search(r'5kmlas_ctl.*calibrate',cmd) : instances['run'] += 1
      elif re.search(r'5kmlas_ctl.*run',cmd) :       instances['run'] += 1
    return instances

class Daemon(Operator):
  '''
  5kmlas daemon process

  the daemon object interacts with the control module in a scripted manner.
  When no runner or calibrator process is in session, it logs PTH and charger
  information infrequently temporary data storage.  Once daily, it also moves
  all data stored in temp storage to data store and rsyncs it to Middle Drum
  '''

  def __init__(self,mode):
    self.mode = mode                   # run mode either poll or store
    instances = self._find_instances() # check to make sure that this process is the only 5kmlas_ctl process
    if instances['run'] > 0:
      sys.exit(0) # do not poll hardware or process data when running
    if instances['poll'] > 0:
      if instances['poll'] > 1 and self.mode == run_mode.poll:
        raise OSError('%d other `5kmlas_ctl poll` process(es) running: only one instance of `5kmlas_ctl` should run at a time.' % instances['poll'])
      elif self.mode == run_mode.store:
        raise OSError('%d other `5kmlas_ctl poll` process(es) running: only one instance of `5kmlas_ctl` should run at a time.' % instances['poll'])
    if instances['store'] > 0:
      if instances['store'] > 1 and self.mode == run_mode.store:
        raise OSError('%d other `5kmlas_ctl store` process(es) running: only one instance of `5kmlas_ctl` should run at a time.' % instances['store'])
      elif self.mode == run_mode.poll:
        raise OSError('%d other `5kmlas_ctl store` process(es) running: only one instance of `5kmlas_ctl` should run at a time.' % instances['store'])

  def run(self,control):
    control.phase = phase.init
    control.init_data()                # init data structure
    if self.mode == run_mode.poll:     # poll data
      control.init_charger()           # init charger
      control.init_PTH()               # init PTH board
      control.on_rain()                # power on rain monitor
      control.poll_rain()              # check rain state
      control.phase = phase.collect
      control.collect_charger_datum()  # collect charger,
      control.collect_PTH_datum()      # PTH data
      control.write_data()             # write data
      control.phase = phase.final
      control.off_rain()               # power off rain monitor
      control.final_PTH()              # final PTH
      control.final_charger()          # final charger
    if self.mode == run_mode.store:    # collate data into gzipped UTC day files
      control.phase = phase.collect
      control.store_data()             # collate and store data
      control.phase = phase.final      # nothing is finalized in store mode

class Runner(Operator):
  '''
  run 5kmlas system

  Runner interfaces with the Control module, which handles state checking and
  automatic shut down in case of error.  The runner object performs a
  scripted routine.
  '''

  def __init__(self):
    wait_time = 30 # time to wait [s] for a daemon process to finish before proceeding
    while True:    # check that this is the only 5kmlas_ctl process
      instances = self._find_instances()
      if instances['poll'] > 0:
        log.inform('A `5kmlas_ctl poll` process is running: waiting %d s for it to finish.\n' % wait_time)
        sleep(wait_time)
      elif instances['store'] > 0:
        log.inform('A `5kmlas_ctl store` process is running: waiting %d s for it to finish.\n' % wait_time)
        sleep(wait_time)
      elif instances['run'] > 1: # this is a run process
        raise OSError('%d other `5kmlas_ctl run` process(es) running: only one instance of `5kmlas_ctl` should run at a time.\n' % instances['run'])
      else:
        break # this is the only `5kmlas_ctl` process running

  def run(self,control,minutes=3):
    control.phase = phase.init
    control.init_data()       # init data structure
    control.init_charger()    # init charger
    control.init_PTH()        # init PTH board
    control.on_rain()         # power on rain monitor
    control.poll_rain()       # check rain state
    control.on_heater()       # power on window heater
    control.on_inverter()     # power on inverter
    control.init_RPC()        # init RPC
    control.on_radiometer()   # power on radiometer
    control.init_radiometer() # init radiometer
    control.on_shutter()      # power on shutter

    control.phase = phase.collect
    collect_time = timedelta(minutes=minutes)           # amount of time to collect laser data
    now = start_time = datetime.datetime.now(UTC())
    control.set_start_time(start_time)                  # record run start time
    control.on_laser()                                  # power on laser
    log.report('collecting data\n',color=log.GRAY)
    while (now < start_time + collect_time):            # collect for collect_time [min]
      control.collect_charger_datum()
      control.collect_PTH_datum()
      sleep(5)                                          # collect charger,PTH data every 5 s
      now = datetime.datetime.now(UTC())                # new timestamp
    control.off_laser()                                 # power off laser
    control.collect_charger_datum()                     # collect final charger datum
    control.collect_PTH_datum()                         # collect final PTH datum
    control.set_stop_time(datetime.datetime.now(UTC())) # record laser off time
    log.report('done collecting\n',color=log.GRAY)

    control.phase = phase.final
    control.off_shutter()              # close shutter
    control.collect_start_stop_times() # record run stop time
    control.collect_radiometer_datum() # read radiometer data and append run times
    control.write_data()               # write data
    control.final_radiometer()         # final radiometer
    control.off_radiometer()           # power off radiometer
    control.final_RPC()                # final RPC
    control.off_inverter()             # power off inverter
    control.off_heater()               # power off window heater
    control.off_rain()                 # power off rain monitor
    control.final_PTH()                # final PTH board
    control.final_charger()            # final charger
    log.detail('%s\n' % control.data)  # print all data when verbose

class DarkBox(Runner):
  '''
  Run parts of 5kmlas system in a dark box on campus in the JFB B39b optics
  lab.  This class will be modified as necessary.
  '''

  def run(self,control,minutes=3):
    control.phase = phase.init
    control.init_data()       # init data structure
    control.init_PTH()        # init PTH board
    control.init_RPC()        # init RPC
    control.on_radiometer()   # power on radiometer
    control.init_radiometer() # init radiometer

    control.phase = phase.collect
    collect_time = timedelta(minutes=minutes)           # amount of time to collect laser data
    now = start_time = datetime.datetime.now(UTC())
    control.set_start_time(start_time)                  # record run start time
    control.on_laser()                                  # power on laser
    log.report('collecting data\n',color=log.GRAY)
    while (now < start_time + collect_time):            # collect for collect_time [min]
      control.collect_PTH_datum()
      sleep(3)                                          # collect charger,PTH data every 3 s
      now = datetime.datetime.now(UTC())                # new timestamp
    control.off_laser()                                 # power off laser
    control.collect_PTH_datum()                         # collect final PTH datum
    control.set_stop_time(datetime.datetime.now(UTC())) # record laser off time
    log.report('done collecting\n',color=log.GRAY)

    control.phase = phase.final
    control.collect_start_stop_times() # record run stop time
    control.collect_radiometer_datum() # read radiometer data and append run times
    control.write_data()               # write data
    control.final_radiometer()         # final radiometer
    control.off_radiometer()           # power off radiometer
    control.final_RPC()                # final RPC
    control.final_PTH()                # final PTH board
    log.detail('%s\n' % control.data)  # print all data when verbose

# main #########################################################################

def parse_opts():
  '''
  handle invocation options and arguments
  '''
  usage = 'Usage: %prog [OPTIONS] MODE'
  description = 'Run 5 km laser calibration system.  MODE is mandatory: "run" - Middle Drum operations [default], "darkbox" - dark box testing, "calibrate" - calibrate 5kmlas, "poll" - poll PTH and charger data, "store" - collate and store data into one part per UTC day.  "poll" and "store" are usually only invoked by cron.'
  opt_parser = OptionParser(usage=usage,description=description,version='%prog-0.7.2')
  opt_parser.add_option('-c','--color',action='store_const',const=True,
      default=True,help='print messages in color [default]')

  verbose = OptionGroup(opt_parser,'Verbosity Options',
      'More quiet options take precedent over more verbose options when more than one is supplied.')
  verbose.add_option('-q','--quiet',action='store_const',const=True,
      default=False,help='print nothing except errors')
  verbose.add_option('-n','--normal',action='store_const',const=True,
      default=False,help='print normal operation messages and errors [default]')
  verbose.add_option('-v','--verbose',action='store_const',const=True,
      default=False,help='print data and serial commands and responses, normal messages, and errors')
  opt_parser.add_option_group(verbose)

  opts,args = opt_parser.parse_args()

  # handle tri-state verbosity option: prefer most quiet option supplied
  if opts.verbose and opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.verbose and opts.normal:
    opts.quiet = False
    opts.verbose = False
  elif opts.verbose and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  # default to normal output
  if not opts.verbose and not opts.normal and not opts.quiet:
    opts.normal = True

  # handle run mode argument
  if len(args) == 1:
    if   args[0] == 'poll'      : args[0] = run_mode.poll
    elif args[0] == 'store'     : args[0] = run_mode.store
    elif args[0] == 'run'       : args[0] = run_mode.run
    elif args[0] == 'darkbox'   : args[0] = run_mode.darkbox
    elif args[0] == 'calibrate' : args[0] = run_mode.calibrate
    else:
      opt_parser.print_usage()
      print opt_parser.expand_prog_name('%%prog: invalid MODE: %s.  Use "%%prog -h" for help.' % args[0])
      sys.exit(1)
  elif len(args) != 1:
    opt_parser.print_usage()
    print opt_parser.expand_prog_name('%prog: please specify exactly one MODE.  Use "%prog -h" for help.')
    sys.exit(1)

  return opts,args

def main():
  opts,args = parse_opts()
  log.init(opts)                         # init logger
  control = Control()                    # init control module
  try: # catch any errors here and shutdown modules gracefully
    if args[0] == run_mode.poll or args[0] == run_mode.store:
      daemon = Daemon(args[0])           # daemon mode
      daemon.run()
    elif args[0] == run_mode.run:
      runner = Runner()                  # running mode
      runner.run(control,minutes=3)      # run for 3 minutes
    elif args[0] == run_mode.darkbox:
      darkbox = DarkBox()                # darkbox mode
      darkbox.run(control,minutes=10)    # run for 10 minutes
    elif args[0] == run_mode.calibrate:
      calibrator = Runner()              # calibration mode
      calibrator.run(control,minutes=5)  # run for 5 minutes
      log.inform('\n\nPlease run `5kmlas_ctl store` before copying data from system.\n\n')
  except KeyboardInterrupt:
    control.auto_shutdown()              # shutdown gracefully
    sys.exit(0)                          # user cancel
  except OSError,oserror:
    log.inform('5kmlas_ctl encountered a system error: "%s".\n' % oserror,color=log.RED)
    control.auto_shutdown()              # shutdown gracefully
    sys.exit(1)                          # system error
  except Exception,exception:
    log.inform('5kmlas_ctl encountered an error: "%s".\n' % exception,color=log.RED)
    control.auto_shutdown()              # shutdown gracefully
    sys.exit(2)                          # other error

if __name__ == '__main__' : main()
