#!/usr/bin/env python
# 5kmlas_ctl - run 5 km laser calibration system
# Wed Feb 16 16:05:00 MST 2011
# findlay@cosmic.utah.edu

# TODO:
# - Run data and non-run PTH data will be written onto the data USB storage as
#   a DST bank.  It will then be transferred to Middle Drum, where it will be
#   pooled into the regular data collection and processing streams as already
#   implemented in Middle Drum software operations.
# - develop rigorous and thorough hardware failure simulation routine
# - replace color code with curses color code
# - replace custom logging with python logging module

# list of modules:
# - control
#   * data
#   * charger
#   * PTH
#     - rain
#     - heater
#     - inverter
#   * RPC
#     - radiometer
#     - shutter
#     - laser
# modules which are always powered on, or in constant use:
#   SBC, PTH, radio, antenna, charger, batteries, solar panels
# modules powered on by SBC controlling program:
#   rain sensor, heater, inverter, RPC, radiometer, shutter, laser

import os,sys,re,socket
from time import sleep
from datetime import datetime,timedelta,tzinfo,time
from optparse import OptionParser,OptionGroup
from serial import Serial,SerialException,SerialTimeoutException
from pymodbus.client.sync import ModbusSerialClient as ModbusClient
from pymodbus.device import ModbusDeviceIdentification
from pymodbus.exceptions import ModbusException
from curses.ascii import US as US_chr

US = chr(US_chr) # unit separator

class Enum:
  # this idiom is from http://norvig.com/python-iaq.html.  It might be better
  # to use collections.namedtuple, but this datatype wasn't added to python
  # until 2.6 and I would have to upgrade debian to squeeze
  '''
  Create an enumerated type, then add var/value pairs to it.
  The constructor and the method .ints(names) take a list of variable names,
  and assign them consecutive integers as values.  The method .strs(names)
  assigns each variable name to itself (that is variable 'v' has value 'v').
  The method .vals(a=99, b=200) allows you to assign any value to variables.
  A 'list of variable names' can also be a string, which will be .split().
  The method .end() returns one more than the maximum int value.

  Example: opcodes = Enum('add sub load store').vals(illegal=255).
  '''

  def __init__(self,names=[]) : self.ints(names)

  def set(self,var,val):
    '''Set var to the value val in the enum.'''
    if var in vars(self).keys() : raise AttributeError('duplicate var in enum')
    if val in vars(self).values() : raise ValueError('duplicate value in enum')
    vars(self)[var] = val
    return self

  def strs(self,names):
    '''Set each of the names to itself (as a string) in the enum.'''
    for var in self._parse(names) : self.set(var,var)
    return self

  def ints(self,names):
    '''Set each of the names to the next highest int in the enum.'''
    for var in self._parse(names) : self.set(var,self.end())
    return self

  def vals(self,**entries):
    '''Set each of var=val pairs in the enum.'''
    for (var,val) in entries.items() : self.set(var,val)
    return self

  def end(self):
    '''One more than the largest int value in the enum, or 0 if none.'''
    try : return max([x for x in vars(self).values() if type(x)==type(0)]) + 1
    except ValueError : return 0

  def lookup(self,num):
    '''Lookup enum value by number.'''
    d = dict((v,k) for k, v in vars(self).iteritems())
    return d[num]

  def _parse(self,names):
    ### If names is a string, parse it as a list of names.
    if type(names) == type('') : return names.split()
    else : return names

verbosity = Enum('quiet normal verbose') # message verbosity
phase = Enum('init run final')           # phase
# hardware states
power_state = Enum('undefined on off')
conf_state = Enum('undefined initialized finalized error')
rain_state = Enum('dry wet open')
# serial states
communication_state = Enum('undefined success error timeout')
# socket IPC
socket_side = Enum('daemon operator calibrator')
signal = Enum('initialize error finalize')

# for some reason I have to implement the notion of UTC
class UTC(tzinfo):
  def __init__(self) : super(UTC,self).__init__()
  def __str__(self) : return 'UTC'
  def __repr__(self) : return self.__str__()
  def tzname(self,dt) : return self.__str__()
  def utcoffset(self,dt) : return timedelta(0)
  def dst(self,dt) : return timedelta(0)
utc = UTC()

class Data:
  '''
  data is written to data part files with one part per UTC day.  Data events
  are streamed into the data object where they are buffered until written to
  the appropriate file.  Each data event contains a timestamp, which is used to
  determine which data part the event will be written to.  If the data
  collected spans more than one UTC day, the event will all go into the day
  that matches its timestamp.
  '''
  def __init__(self):
    self.storage_location = '/tmp/data' # location of data files
    if not os.path.exists(self.storage_location):
      os.makedirs(self.storage_location)
    if not os.path.isdir(self.storage_location):
      raise OSError('data storage location is not a directory')
    self.buffer = []
    self.zero_datetime = datetime.utcfromtimestamp(0) # 1970-01-01 00:00:00.000000 UTC
    self.zero_time = time(0,0,0,0,utc) # 00:00:00.000000 UTC

  def append(self,*args,**kwargs):
    for kwarg in kwargs:
      self.buffer.append(kwargs[kwarg])

  def write(self):
    # TODO:
    # load objects from DST.py and write data structure into DST file the
    # format of the DST file will be a heterogeneous stream with one part per
    # UTC day.  Once data has been written to storage, clear all data from
    # memory
    #
    # for now, just write the data to one ASCII file per UTC day
    self.files = {}
    self.buffer.sort(key=lambda item : item['timestamp']) # sort data by timestamp
    for item in self.buffer:
      if not item['timestamp'] in self.files.keys():
        self.files[item['timestamp']] = self._get_file(item['timestamp'])
      f = self.files[item['timestamp']]                   # current file
      f.write('type:%s\n' % item['type'])                 # write item type
      f.write('  timestamp:%s\n' % item['timestamp'])     # write item timestamp
      for key,val in sorted(item.items()):                # write remaining data sorted by key
        if not key == 'type' and not key == 'timestamp':
          if isinstance(val[0],int):
            f.write('  %s: %d %s\n' % (key,val[0],val[1]))
          elif isinstance(val[0],float):
            f.write('  %s: %f %s\n' % (key,val[0],val[1]))
          else:
            f.write('  %s: %s %s\n' % (key,val[0],val[1]))
      f.flush() ; os.fsync(f.fileno()) # need to flush file buffer to ensure sequential write
    self._clear()

  def _clear(self):
    for timestamp in self.files.keys():
      self.files[timestamp].close() # close file objects
    del self.files                  # remove file object container
    del self.buffer[:]              # clear data buffer

  def _get_file(self,timestamp):
    date = datetime.combine(timestamp,self.zero_time).date()
    return file(os.path.join(self.storage_location,'%s' % date),'a')

# module abstract base classes #################################################

class SerialModule(Serial):
  '''
  abstract base class for serial modules

  This class provides error handling for initializing, reading, and writing
  serial devices.  If an exception is raised by pyserial, a serial module flag
  is set and then handled by the control module.
  '''

  def __init__(self,buffer_size,*args,**kwargs):
    self.buffer_size = buffer_size
    self.communication_state = communication_state.undefined
    try:
      super(SerialModule,self).__init__(*args,**kwargs)
    except SerialException,serial_exception:
      self.conf_state = conf_state.error
      self.message = 'failed to initialize %s serial connection: %s' % (self.name,serial_exception)
      return

  def read(self):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).read(self.buffer_size).strip()
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to read from serial device %s: %s' % (self.name,serial_exception)
      return '' # classes derived from SerialModule always expect a return value of str type

  def write(self,data):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).write(data)
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to write to serial device %s: %s' % (self.name,serial_exception)
      return
    except SerialTimeoutException,timeout_exception:
      self.communication_state = communication_state.timeout
      self.message = 'failed to write to serial device %s: %s' % (self.name,timeout_exception)
      return

class ModbusModule(ModbusClient):
  '''
  abstract base class for modbus modules.  Modbus is a protocol that can run on
  top of serial,TCP,UDP.  ModbusClient contains a pySerial interface
  '''

  def __init__(self,*args,**kwargs):
    self.communication_state = communication_state.undefined
    try:
      super(ModbusModule,self).__init__(*args,**kwargs)
    except ModbusException,modbus_exception:
      self.conf_state = conf_state.error
      self.message = 'failed to initialize %s modbus connection: %s' % (self.name,serial_exception)
      return

  # TODO: overload modbus methods and catch modbus errors here
  # try: except ModbusException:

class PowerModule(object):
  '''
  abstract base class for power modules
  '''

  def __init__(self):
    pass

# module classes ###############################################################

class ChargeController(ModbusModule):
  def __init__(self):
    self.name = 'charger'   # charger module name
    self.conf_message = ''  # state message
    self.message = ''       # result message
    self.define_enums_bitfields()
    super(ChargeController,self).__init__(method='rtu',port='/dev/tts/3',baudrate=9600,bytesize=8,parity='N',stopbits=2,timeout=1)
    self.set_conf_state()

  def define_enums_bitfields(self):
    self.enums = {}
    self.bitfields = {}
    # enums
    self.enums['charge state'] = Enum().vals(
        START      =0,
        NIGHT_CHECK=1,
        DISCONNECT =2,
        NIGHT      =3,
        FAULT      =4,
        BULK_CHARGE=5,
        ABSORPTION =6,
        FLOAT      =7,
        EQUALIZE   =8)
    self.enums['load state'] = Enum().vals(
        START      =0,
        LOAD_ON    =1,
        LVD_WARNING=2,
        LVD        =3,
        FAULT      =4,
        DISCONNECT =5)
    self.enums['LED state'] = Enum().vals(
        LED_START                 =0,
        LED_START2                =1,
        LED_BRANCH                =2,
        EQUALIZE_FAST_GREEN_BLINK =3,
        FLOAT_SLOW_GREEN_BLINK    =4,
        ABSORPTION_GREEN_BLINK_1HZ=5,
        GREEN_LED                 =6,
        UNDEFINED_7               =7,
        YELLOW_LED                =8,
        UNDEFINED_9               =9,
        BLINK_RED_LED             =10,
        RED_LED                   =11,
        R_Y_G_ERROR               =12,
        RY_G_ERROR                =13,
        RG_Y_ERROR                =14,
        R_Y_ERROR_HTD             =15,
        R_G_ERROR_HVD             =16,
        RY_GY_ERROR               =17,
        GYR_ERROR                 =18,
        GYR_x_2                   =19)
    # bitfields
    #    state                                         bit
    self.bitfields['array fault'] = [
        'overcurrent',                               # 0
        'FETs shorted',                              # 1
        'software bug',                              # 2
        'battery HVD',                               # 3
        'array HVD',                                 # 4
        'EEPROM setting edit (reset required)',      # 5
        'RTS shorted',                               # 6
        'RTS was valid, now disconnected',           # 7
        'local temp. sensor failed',                 # 8
        'Fault 10',                                  # 9
        'Fault 11',                                  # 10
        'Fault 12',                                  # 11
        'Fault 13',                                  # 12
        'Fault 14',                                  # 13
        'Fault 15',                                  # 14
        'Fault 16']                                  # 15
    self.bitfields['load fault'] = [
        'external short circuit',                    # 0
        'overcurrent',                               # 1
        'FETs shorted',                              # 2
        'software bug',                              # 3
        'HVD',                                       # 4
        'heatsink over-temperature',                 # 5
        'EEPROM setting edit (reset required)',      # 6
        'Fault 8']                                   # 7
    self.bitfields['alarm'] = [
        'RTS open',                                  # 0
        'RTS shorted',                               # 1
        'RTS disconnected',                          # 2
        'Ths open',                                  # 3
        'Ths shorted',                               # 4
        'SSMPPT hot',                                # 5
        'Current limit',                             # 6
        'Current offset',                            # 7
        'Undefined',                                 # 8
        'Undefined',                                 # 9
        'Uncalibrated',                              # 10
        'RTS miswire',                               # 11
        'Undefined',                                 # 12
        'Undefined',                                 # 13
        'miswire',                                   # 14
        'FET open',                                  # 15
        'P12',                                       # 16
        'high Va current limit',                     # 17
        'Alarm 19',                                  # 18
        'Alarm 20',                                  # 19
        'Alarm 21',                                  # 20
        'Alarm 22',                                  # 21
        'Alarm 23',                                  # 22
        'Alarm 24']                                  # 23
    self.bitfields['dip switch'] = [
    #    1 value                              0 value                     function              bit  
        'custom battery settings',          # User Select jumper          Battery Type          0
        'custom load settings',             # 11.5 V / 12.6 V             LVD / LVR             1
        'enabled (if battery type has EQ)', # disabled                    Equalize              2
        'MODBUS protocol']                  # Meterbus (MS remote meter)  Communication Select  3

  def structure_data(self,registers):
    '''
    puts charger data into a structure and performs numerical conversions
    '''
    self.scale = { # scale factors
        'V':100.*2.**-15.,
        'V ref':96.667*2.**-15.,
        'A':79.16*2.**-15.,
        'W':989.*2.**-16.,
        'Ah':0.1,
        'kWh':0.1,
        'ratio':2.**-8.}
    data_dict = { # dict of tuples of measurements and associated units
        'type':                  'charger',                                     # type of data structure
        'timestamp':              datetime.now(utc),                            # [datetime object] Time stamp
        'battery volts':         (registers[0x0008]*self.scale['V'],'V'),       # [V] (tau = 1 s) Voltage measured directly at the battery connection on the SunSaver MPPT.
        'array volts':           (registers[0x0009]*self.scale['V'],'V'),       # [V] (tau = 1 s) Va is the terminal voltage of the solar input connection.
        'load volts':            (registers[0x000A]*self.scale['V'],'V'),       # [V] (tau = 1 s) Vl is the terminal voltage of the load output connection.
        'charging current':      (registers[0x000B]*self.scale['A'],'A'),       # [A] (tau = 1 s) Charging current to the battery as measured by on-board shunt.
        'load current':          (registers[0x000C]*self.scale['A'],'A'),       # [A] (tau = 1 s) Load current to the systems loads as measured by on-board shunt.
        'heatsink temp':         (registers[0x000D],'^oC'),                     # [^oC] Sunsaver MPPT Heatsink temperature.
        'battery temp':          (registers[0x000E],'^oC'),                     # [^oC] Battery temperature as measured by the ambient temperature sensor or the optional RTS (if connected).
        'ambient temp':          (registers[0x000F],'^oC'),                     # [^oC] Ambient temperature as measured by the ambient temperature sensor.
        # 0x0010, RTS is redundant
        'charge state':          (registers[0x0011],'enum'),                    # [enum] Reports the charge state.
        'array fault':           (registers[0x0012],'bitfield'),                # [bitfield] Reports faults identified by self diagnostics.
        'slow battery volts':    (registers[0x0013]*self.scale['V'],'V'),       # [V] (tau = 25 s) Voltage measured directly at the battery connection on the SunSaver MPPT.
        'battery ref':          (registers[0x0014]*self.scale['V ref'],'V'),    # [V] Target voltage to which the battery will be charged. This value is temperature compensated.
        'Ah resetable charge':  ((registers[0x0015]<<16 | registers[0x0016])*self.scale['Ah'],'Ah'), # [A*h] Reports total solar amp-hours since last ah reset.
        'Ah total charge':      ((registers[0x0017]<<16 | registers[0x0018])*self.scale['Ah'],'Ah'), # [A*h] Reports total solar amp-hours since last ah reset.
        'kWh charge':            (registers[0x0019]*self.scale['kWh'],'kWh'),   # [kW*h] Reports total solar kilowatt-hours since last ah/kWh reset.
        'load state':            (registers[0x001A],'enum'),                    # [enum] Reports the charge state.
        'load fault':            (registers[0x001B],'bitfield'),                # [bitfield] Reports faults identified by self diagnostics.
        'low disconnect volts': (registers[0x001C]*self.scale['V'],'V'),        # [V] Low voltage disconnect setpoint, current compensated.
        'resetable load':       ((registers[0x001D]<<16 | registers[0x001E])*self.scale['Ah'],'Ah'), # [A*h] Reports total load amp-hours since last ah reset.
        'total load':           ((registers[0x001F]<<16 | registers[0x0020])*self.scale['Ah'],'Ah'), # [A*h] Reports total load amp-hours since last ah reset.
        'hour meter':            (registers[0x0021]<<16 | registers[0x0022],'h'), # [h] Reports total hours of operation since installed.
        'alarm':                 (registers[0x0023]<<16 | registers[0x0024],'bitfield'), # [bitfield] Reports alarms identified by self diagnostics. Each bit corresponds to a specific alarm.
        'dip switch':            (registers[0x0025],'bitfield'),                # [bitfield] Each bit in the bit-field corresponds to an individual DIP switch setting.
        'LED state':             (registers[0x0026],'enum'),                    # [enum] Reports the LED state.
        'power out':             (registers[0x0027]*self.scale['W'],'W'),       # [W] Output power to the battery.
        # sweep data is irrelevant, since the charger is regularly polled
       #'sweep Vmp':             (registers[0x0028]*self.scale['V'],'V'),       # [V] Maximum power voltage of the solar array found during last sweep.
       #'sweep Pmax':            (registers[0x0029]*self.scale['W'],'V'),       # [W] Maximum power output of the solar array found during last sweep.
       #'sweep Voc':             (registers[0x002A]*self.scale['V'],'V'),       # [V] Open circuit voltage of the solar array found during last sweep.
       #'daily Vb min':          (registers[0x002B]*self.scale['V'],'V'),       # [V] Minimum battery voltage measured today (value resets after dark).
       #'daily Vb max':          (registers[0x002C]*self.scale['V'],'V'),       # [V] Maximum battery voltage measured today (value resets after dark).
       #'daily Ah load':         (registers[0x002E]*self.scale['Ah'],'Ah'),     # [A*h] Total load amp-hours accumulated today (value resets after dark).
       #'daily array fault':     (registers[0x002F],'bitfield'),                # [bitfield] Reports array faults identified by self diagnostics that occurred today.
       #'daily load fault':      (registers[0x0030],'bitfield'),                # [bitfield] Reports load faults identified by self diagnostics that occurred today.
       #'daily alarm':           (registers[0x0031]<<16 | registers[0x0032],'bitfield'), # [bitfield] Reports alarms identified by self diagnostics that occurred today.
       #'min Vb':                (registers[0x0033]*self.scale['V'],'V'),       # [V] Tracks the minimum battery voltage over time.
       #'max Vb':                (registers[0x0034]*self.scale['V'],'V'),       # [V] Tracks the maximum battery voltage over time.
        }
    return data_dict

  def set_conf_state(self): # TODO: read vendor name, etc.
    self.conf_state = conf_state.initialized # module conf state

  def poll_data(self):
    registers = self.read_holding_registers(0x0000,0x0028,unit=0x01).registers
    data_dict = self.structure_data(registers)
    self.convert_enums_bitfields(data_dict)
    return data_dict

  def convert_enums_bitfields(self,data_dict):
    # convet enums
    for parameter in ('charge state','load state','LED state'):
      state = self.enums[parameter].lookup(data_dict[parameter][0])
      data_dict[parameter] = (state,'enum')
    # convert bitfields
    for parameter in ('array fault','load fault','alarm','dip switch'):
      state = []
      for offset in xrange(32): # 2**32 == 16**8, MPPT double register data values are 16**8 large
        if (data_dict[parameter][0] >> offset) & 1:
          state.append(self.bitfields[parameter][offset])
      data_dict[parameter] = (state,'bitfield')

class PTH(SerialModule):
  '''
  PTH module

  ?|HELP                  - help
  AIN [B|C|D|E]           - read inputs as analog (V)
  AMON [B|C|D|E] [<th>]   - set analog input threshold (V)
  AUTO [<sec>]            - set automatic readout period - 0 disables
  ECHO [0|1]              - serial echo - 0=disable 1=enable
  HEAT [0|1]              - set SHT11 heater - 0=off 1=on
  HUMID                   - read humidity (%RH)
  IN [A|B|C|D|E]          - read inputs as digital (0|1)
  OUT [A|B|C|D|E] [0|1]   - read [set] isolated output
  PRESS                   - read pressure (kPa)
  RAIN                    - read rain sensor dry|wet|open (D|W|X)
  RMON [0|1]              - set rain monitor enable
  SUPPLY                  - read supply voltage (V)
  TEMP                    - read temperture (degK)
  TENAB [0|1]             - set thermostat enable - 0 disables
  THIGH [<temp>]          - set cooler set point (output D)
  TLOW [<temp>]           - set heater set point (output E)
  VER                     - read device firmware version
  '''

  def __init__(self,*args,**kwargs):
    self.buffer_size = 65536    # = 2**2**2**2 : termios read buffer size
    self.name = 'PTH board'     # PTH module name
    self.conf_message = ''      # state message
    self.message = ''           # result message
    super(PTH,self).__init__(self.buffer_size,'/dev/tts/0',baudrate=9600,timeout=0.5)
    self.write('ECHO 0\r\n') # disable PTH-side serial echo
    self.read()              # clear output buffer
    self.set_conf_state()

  def set_conf_state(self):
    self.write('VER\r\n')                         # check PTH initialized
    self.conf_message = self.read()               # read state message
    if re.search(r'VER\s+\S+',self.conf_message): # parse version message
      self.conf_state = conf_state.initialized    # module conf state
      self.message = 'PTH version: "%s"' % self.conf_message
    else:                                         # PTH did not print version message
      self.conf_state = conf_state.error
      self.message = 'PTH did not print version message.'
      self.message += '\nPTH output: "%s"' % self.conf_message

  def on(self,module=None): # close a PTH switch
    self.write('%s\r\n' % module.PTH_on_command) # close PTH switch for module
    module.PTH_message = self.read()             # capture PTH message
    self.set_power_state(module=module)       # check module power on
    if module.power_state == power_state.on:     # if module powered on
      sleep(module.power_on_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                        # module failed to power on
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_on_command

  def off(self,module=None): # open a PTH switch
    self.write('%s\r\n' % module.PTH_off_command) # open PTH switch for module
    module.PTH_message = self.read()              # capture PTH message
    self.set_power_state(module=module)        # check module power off
    if module.power_state == power_state.off:     # if module powered off
      sleep(module.power_off_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                         # module failed to power off
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_off_command

  def set_power_state(self,module=None):
    if re.search(r'%s' % module.PTH_on_command,module.PTH_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'%s' % module.PTH_off_command,module.PTH_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

  def poll_data(self):
    self.read() # clear output buffer
    self.write('PRESS\r\n')  ; press  = re.search(r'PRESS\s+(\S+)',self.read()).group(1)
    self.write('TEMP\r\n')   ; temp   = re.search(r'TEMP\s+(\S+)',self.read()).group(1)
    self.write('HUMID\r\n')  ; humid  = re.search(r'HUMID\s+(\S+)',self.read()).group(1)
    self.write('RAIN\r\n')   ; rain   = re.search(r'RAIN\s+(\S+)',self.read()).group(1)
    self.write('SUPPLY\r\n') ; supply = re.search(r'SUPPLY\s+(\S+)',self.read()).group(1)
    data_dict = {
        'type':'PTH',
        'timestamp':datetime.now(utc),
        'PRESS':(press,'Pa'),
        'TEMP':(temp,'K'),
        'HUMID':(humid,'%'),
        'RAIN':(rain,'enum'),
        'SUPPLY':(supply,'V')}
    return data_dict

  def poll_rain(self,module=None):
    self.read() # clear output buffer
    self.write('RAIN\r\n')
    message = re.search(r'(RAIN\s+\S+)',self.read()).group(1) # read rain state
    if len(message) != 0:
      module.PTH_message = message
      rain_datum = re.split(r'\s+',module.PTH_message)
      self.set_rain_state(rain_datum,module=module)
    else:
      pass # a call to self.read sets the communication_state flag, so we don't need to handle it here

  def set_rain_state(self,rain_datum,module=None):
    if rain_datum[1] == 'D': # dry
      module.rain_state = rain_state.dry
      module.message = 'no rain: "%s"' % module.PTH_message
    if rain_datum[1] == 'W': # wet
      module.rain_state = rain_state.wet
      module.message = 'rain detected: "%s"' % module.PTH_message
    if rain_datum[1] == 'X': # open or no rain monitor
      module.rain_state = rain_state.open
      module.message = '%s open or no %s present: "%s"' % (module.name,module.name,module.PTH_message)

class Rain(PowerModule):
  '''rain module'''

  def __init__(self):
    self.name = 'rain monitor'               # rain module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'RMON'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 5                  # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Heater(PowerModule):
  '''heater module'''

  def __init__(self):
    self.name = 'window heater'              # heater module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'HEAT'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 1 # 30             # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Inverter(PowerModule):
  '''inverter module'''

  def __init__(self):
    self.name = 'power inverter'             # inverter module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'A'                    # PTH board switch name
    self.PTH_on_command = 'OUT %s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = 'OUT %s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 10                 # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class RPC(SerialModule):
  '''
  RPC module

  RPC-2 Series
  (C) 1997 by BayTech
  F2.07

  Circuit Breaker: On

  1)...Outlet 1  : Off
  2)...Outlet 2  : Off
  3)...Outlet 3  : Off
  4)...Outlet 4  : Off
  5)...Outlet 5  : Off
  6)...Outlet 6  : Off
  '''

  def __init__(self):
    self.buffer_size = 65536 # = 2**2**2**2 : termios read buffer size
    self.name = 'RPC module' # RPC module name
    self.conf_message = ''   # state message
    self.message = ''        # result message
    super(RPC,self).__init__(self.buffer_size,'/dev/tts/1',baudrate=9600,timeout=1)
    self.set_conf_state()

  def set_conf_state(self):
    self.conf_message = self.read()             # init message
    if re.search(r'BayTech',self.conf_message): # parse message for 'BayTech' string
      self.conf_state = conf_state.initialized  # module conf state
      self.message = 'RPC initialized.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message
    else: # not a BayTech RPC, no RPC present, or if RPC prints out a message, the message doesn't contain 'BayTech'
      self.conf_state = conf_state.error
      self.message = 'RPC did not initialize.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message

  def on(self,module=None): # power on a RPC outlet
    self.write('ON %d\r\n' % module.RPC_outlet)# power on RPC outlet for module
    sleep(0.5) ; self.write('Y\r\n')           # wait 0.5 s and confirm power on
    module.RPC_message = self.read()           # capture RPC message
    self.set_power_state(module=module)      # check powered on
    if module.power_state == power_state.on:   # if module powered on
      sleep(module.power_on_sleep)             # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                      # module failed to power on
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : On"' % (module.RPC_outlet,module.RPC_outlet)

  def off(self,module=None): # power off a RPC outlet
    self.write('OFF %d\r\n' % module.RPC_outlet) # power off RPC outlet for module
    sleep(0.5) ; self.write('Y\r\n')             # wait 0.5 s and confirm power off
    module.RPC_message = self.read()             # capture RPC message
    self.set_power_state(module=module)        # check powered off
    if module.power_state == power_state.off:    # if module powered off
      sleep(module.power_off_sleep)              # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                        # module failed to power off
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : On"' % (module.RPC_outlet,module.RPC_outlet)

  def set_power_state(self,module=None):
    if re.search(r'^.*Outlet\s+%d\s+:\s+On.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'^.*Outlet\s+%d\s+:\s+Off.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

class Radiometer(SerialModule,PowerModule):
  '''
  radiometer module

  Auger CLF radiometer (RM-3700) settings from lwiencke:
  ID       Identity(3700)
  VR       Version
  TG 3     Trigger (0 internal, 3 external - positive edge)
  SS 0     Single shot (1 enable, 0 disable)
  FA 1.00  Calibration Factor Channel A - we use 1.00
  WA 335   Wavelength of laser(used to correct for Si probe response,)
  PA       Probe id and type (23 0 : 465 Si ), (2 0 : 734 pyro)
  EV 1     Event average       (should be 1)
  BS 0     In case this radiometer has batteries installed
  RA 4     Range  1,2,3:X,XX,XXX e-12 | 4,5,6:X,XX,XXX e-9 pJ
  ST       Return error status (should be 0)
  AD       ASCII Dump Mode
  '''

  def __init__(self): # software init
    self.name = 'radiometer'                 # radiometer module name
    self.power_state = power_state.undefined # power state
    self.conf_state = conf_state.undefined   # configuration state
    self.RPC_outlet = 1                      # RPC outlet number
    self.power_on_sleep = 0                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.conf_message = ''                   # state message
    self.message = ''                        # result message

  def init(self): # hardware init
    self.buffer_size = 65536          # = 2**2**2**2 : termios read buffer size
    # TODO: figure out how long the timeout needs to be to capture 5 m worth of radiometer data
    super(Radiometer,self).__init__(self.buffer_size,'/dev/tts/2',baudrate=9600,timeout=5)
    # the radiometer needs a timeout between consecutive commands
    sleep(0.5) ; self.write('TG 1\r') # internal trigger
    sleep(0.5) ; self.write('SS 0\r') # no single shot
    sleep(0.5) ; self.write('RA 2\r') # range 2: TODO: energy limits on this range?
    sleep(0.5) ; self.write('BS 0\r') # disable internal battery save
    #self.flushInput()
    #self.flushOutput()     # doesn't work when run from SBC
    self.read()             # clear output buffer
    self.set_conf_state()
    self.write('AD\r')      # ASCII dump

  def set_conf_state(self):
    self.write('ST\r')                      # check error status
    self.conf_message = self.read().strip() # strip leading,trailing whitespace
    if re.search(r'0',self.message):        # if no errors
      self.conf_state = conf_state.initialized
      self.message = 'radiometer returned error status "0", no error'
    else: # TODO: try to figure out how to get radiometer into 0 (no) error state
      #self.conf_state = conf_state.error
      self.conf_state = conf_state.initialized
      self.message = 'radiometer returned error status "%s"' % self.conf_message

  def read_data(self):
    energies = []
    for i in re.split(r'\s+',self.read()):
      try: # only return the numbers from the radiometer message
        energies.append(float(i))
      except:
        pass
    data_dict = {'type':'radiometer','timestamp':datetime.now(utc),'energies':(energies,'J')}
    return data_dict

class Shutter(PowerModule):
  '''shutter module'''

  def __init__(self):
    self.name = 'shutter'                    # shutter module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 3                      # RPC outlet number
    self.power_on_sleep = 10                 # time to wait after power on
    self.power_off_sleep = 10                # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

class Laser(PowerModule):
  '''laser module'''

  def __init__(self):
    self.name = 'laser'                      # laser module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 2                      # RPC outlet number
    self.power_on_sleep = 2                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

# control modules ##############################################################

def is_at_timepoint(t,d,e):
  '''
  test whether the current time t is within an epsilon e of one of the
  timepoints n defined by n*d = 1 day, where d is a time difference

  It is expected that 0 < e < d and d will be within the range 1 <= d <= 86400 s.
  '''
  day = timedelta(days=1)
  n = 0 # number of timepoints within a day
  while True:
    if n*d >= day:
      break
    n += 1

  timepoints = []
  for i in xrange(n):
    h = i*(d.seconds/3600)
    m = i*(d.seconds%3600/60)
    s = i*(d.seconds%3600%60)
    timepoints.append(timedelta(hours=h,minutes=m,seconds=s))

  # treat current time as timedelta from beginning of day
  h,m,s = t.timetuple()[3:6]
  now = timedelta(hours=h,minutes=m,seconds=s)
  for timepoint in timepoints:
    if abs(now - timepoint) <= e:
      return True

class Socket(socket.socket):
  def __init__(self,side=None):
    super(Socket,self).__init__(socket.AF_UNIX,socket.SOCK_STREAM)
    self.buffer_size = 65536            # = 2**2**2**2
    self.name = '/tmp/5kmlas_socket'
    self.side = side                    # this Socket instance is on side daemon, operator, or calibrator
    if self.side == socket_side.daemon: # daemon sets up server side of socket
      self.remove()                     # remove the socket if it exists
      self.bind(self.name)              # create and bind to socket
      self.listen(1)                    # there are only two processes and one socket at a time
      self.settimeout(0.0)              # do not block when reading the socket
    elif self.side == socket_side.operator or self.side == socket_side.calibrator:
      try:
        self.connect(self.name)         # operator process connects to the existing socket
      except socket.error,error:
        print 'cannot connect to %s: %s' % (self.name,error)
        sys.exit(1)

  def __del__(self):
    self.remove()
    # socket.socket doesn't have a __del__ method

  def remove(self):
    '''
    remove unix socket from filesystem
    '''
    if self.side == socket_side.daemon:
      if os.path.lexists(self.name):
        os.remove(self.name) # only the daemon process removes the socket

  def close(self):
    if self.side == socket_side.daemon:
      self.conn.close()          # daemon closes its connection object
    elif self.side == socket_side.operator or self.side == socket_side.calibrator:
      super(Socket,self).close() # operator closes itself

  def accept(self):
    '''
    daemon object tries to accept a socket connection
    '''
    if self.side == socket_side.daemon:
      try:
        self.conn,self.addr = super(Socket,self).accept()
        return True
      except socket.error:
        return False

  def read(self):
    '''
    read from socket

    Unix domain sockets are different from TCP sockets in that one read flushes
    the whole buffer.  We must ensure that self.buffer_size is large enough to
    capture any IPC transaction and is smaller than SO_RCVBUF.  64 Kib should
    be large enough.  See unix(7) and socket(7) for more information.
    '''
    if self.side == socket_side.daemon:
      data = self.conn.recv(self.buffer_size) # daemon reads from connection object
    elif self.side == socket_side.operator or self.side == socket_side.calibrator:
      data = self.recv(self.buffer_size)      # operator reads from socket object
    return data.strip()                       # remove extra whitespace

  def write(self,data):
    '''
    write data to socket
    '''
    if self.side == socket_side.daemon:
      return self.conn.send(data) # daemon reads from connection object
    elif self.side == socket_side.operator or self.side == socket_side.calibrator:
      return self.send(data)      # operator reads from socket object

class Control(object):
  '''
  abstract base class for software control modules daemon and operator

  The control module is an abstract base class for the daemon and operator
  modules.  Together they wrap each serial communication to the physical
  modules in order to simplify and unify error traps.  Each call sets one or
  more associated states in the module.  The control module will take action
  upon each setting of state: either proceed normally or try to return the
  hardware and software to a well-defined and safe state.

  This scheme assumes at least three things:
  - The python code and the operating system it runs on are either so much more
    reliable in comparison with the hardware that they aren't worth checking or
    they will provide their own error handling when necessary.
  - The firmware on the hardware is so much more reliable than the hardware
    itself that all problems will originate with a hardware failure or
    misconfiguration and that the firmware will report it.
  - The hardware modules will fail only at the time of a state change or a
    serial write
  If any of the serial devices (PTH,RPC,radiometer) fail on the negotiation of
  the serial connection or when any data is sent to them, pyserial will handle
  and report those errors and the control module will intercept those errors
  and shutdown as appropriate.

  The control process has three phases: init, run, and final.  Depending on the
  phase and module, the control module may fail in a different manner.
  '''

  def __init__(self,opts):
    # process invocation settings
    if opts.verbose:                     # verbose output
      self.verbosity = verbosity.verbose
    if opts.normal:                      # normal output
      self.verbosity = verbosity.normal
    if opts.quiet:                       # no output except errors
      self.verbosity = verbosity.quiet
    if opts.color:                       # colorful output
      self.color = opts.color

    self.setup_color()
    self.setup_modules()

  def setup_color(self):
    # modified from https://svn.blender.org/svnroot/bf-blender/trunk/blender/tools/bcolors.py
    if self.color == True:
      self.CYAN   = '\033[96m'
      self.VIOLET = '\033[95m'
      self.BLUE   = '\033[94m'
      self.YELLOW = '\033[93m'
      self.GREEN  = '\033[92m'
      self.RED    = '\033[91m'
      self.GRAY   = '\033[90m'
      self.ENDC   = '\033[0m'
    else: # no color
      self.CYAN   = ''
      self.VIOLET = ''
      self.BLUE   = ''
      self.YELLOW = ''
      self.GREEN  = ''
      self.RED    = ''
      self.GRAY   = ''
      self.ENDC   = ''

  def setup_modules(self):
    # create submodule stubs
    self.charger = None
    self.PTH = None
    self.rain = None
    self.heater = None
    self.inverter = None
    self.RPC = None
    self.radiometer = None
    self.shutter = None
    self.laser = None
    # create list for modules that won't turn off
    self.modules_no_off = []

  def read_socket(self):
    signals,commands = [],[]
    try:
      data = self.socket.read()
    except socket.error,error:
      data = ''                             # TODO: take appropriate action
    for unit in re.split(US,data):          # split inbound data into units
      try:
        signals.append(int(unit))           # unit is a signal
      except ValueError:                    # unit is a python statement
        nunit = re.sub(r'\n',r'\\n',unit)   # escape all NLs in statement
        rnunit = re.sub(r'\r',r'\\r',nunit) # escape all CRs in statement
        commands.append(rnunit)
    return signals,commands

  def write_socket(self,unit):
    '''
    write data to socket

    Lines are terminated with US character.
    '''
    try:
      return self.socket.write('''%s%s''' % (unit,US))
    except socket.error,error:
      return # TODO: take appropriate action

  def printf(self,data,color=''):
    '''
    write to sys.stdout
    '''
    if color : data = color + data + self.ENDC
    sys.stdout.write(data)
    sys.stdout.flush()

  def inform(self,data,color=''):
    '''
    write error information to sys.stdout even in quiet mode
    '''
    self.printf(data,color=color)
    # the daemon passes its messages on to the operator or calibrator process when it's connected
    if self.connected and isinstance(self,Daemon):
      self.write_socket('''self.printf("""%s""",color="""%s""")''' % (data,color))

  def report(self,data,color=''):
    '''
    write normal-level information to sys.stdout
    '''
    if self.verbosity > verbosity.quiet:
      self.printf(data,color=color)
    if self.connected and isinstance(self,Daemon):
      self.write_socket('''if self.verbosity > verbosity.quiet : self.printf("""%s""",color="""%s""")''' % (data,color))

  def detail(self,data,color=''):
    '''
    write verbose-level information to sys.stdout
    '''
    if self.verbosity == verbosity.verbose:
      self.printf(data,color=color)
    if self.connected and isinstance(self,Daemon):
      self.write_socket('''if self.verbosity == verbosity.verbose : self.printf("""%s""",color="""%s""")''' % (data,color))

  # state checks
  def check_conf_state(self,desired_state,module=None):
    if module.conf_state == desired_state:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    elif module.conf_state == conf_state.undefined or module.conf_state == conf_state.finalized:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown()
    elif module.conf_state == conf_state.error:
      self.inform('error\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown()

  def check_power_state(self,desired_state,module=None):
    if module.power_state == desired_state:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    else:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown(module_no_off=module)

  def check_rain_state(self,module=None):
    if module.rain_state == rain_state.dry:
        self.report('dry\n',color=self.GRAY)
        self.detail('%s\n' % module.message)
    elif module.rain_state == rain_state.wet:
      self.report('wet\n',color=self.BLUE)
      self.report('%s\n' % module.message)
      if self.phase != phase.final:
        self.emergency_shutdown()
    elif module.rain_state == rain_state.open:
      self.report('open\n',color=self.YELLOW)
      self.report('%s\n' % module.message)
      if self.phase != phase.final:
        #self.emergency_shutdown() # TODO: get rain sensor
        self.off_rain()

  def check_communication_state(self,module=None):
    if module.communication_state == communication_state.success:
      return # serial module successfully written to or read from
    elif module.communication_state == communication_state.error:
      self.emergency_shutdown()
    elif module.communication_state == communication_state.timeout:
      self.emergency_shutdown()

  def emergency_shutdown(self,module_no_off=None):
    '''
    To avoid an open loop, we will not try to final or power off any module
    that won't do so.
    '''
    # TODO: update for two process scenario
    if module_no_off:
      self.modules_no_off.append(module_no_off)
    self.verbosity = verbosity.verbose
    self.inform('\nshutting down 5kmlas\n',color=self.RED)
    # if laser module exists and isn't the module that won't turn off
    if self.laser and not self.laser in self.modules_no_off:
      if self.laser.power_state == power_state.on:
        self.off_laser()
        self.read_radiometer_data() # if the laser is on, then there may be some data
        self.data.write()           # try to save whatever data we have
    if self.shutter and not self.shutter in self.modules_no_off:
      if self.shutter.power_state == power_state.on:
        self.off_shutter()
    if self.radiometer and not self.radiometer in self.modules_no_off:
      if self.radiometer.power_state == power_state.on:
        self.off_radiometer()
    if self.inverter and not self.inverter in self.modules_no_off:
      if self.inverter.power_state == power_state.on:
        self.off_inverter()
    if self.heater and not self.heater in self.modules_no_off:
      if self.heater.power_state == power_state.on:
        self.off_heater()
    if self.rain and not self.rain in self.modules_no_off:
      if self.rain.power_state == power_state.on:
        self.off_rain()
    # TODO: perhaps set a flag on the SBC to not run again if there is a problem
    sys.exit(1) # system should now be in as safe of a state as possible

  # data commands
  def init_data(self):
    self.data = Data() # data structure

  def write_data(self):
    if self.phase == phase.final:
      self.report('writing data ... ')
    else:
      self.detail('writing data ... ')
    self.data.write() # format and save data, then clear data buffer
    if self.phase == phase.final:
      self.report('done\n',color=self.GREEN)
    else:
      self.detail('done\n',color=self.GREEN)

  # charger commands
  def init_charger(self):
    self.report('initializing charger modbus interface ... ')
    self.charger = ChargeController()                                 # init charger
    self.check_communication_state(module=self.charger)               # check write state
    self.check_conf_state(conf_state.initialized,module=self.charger) # check charger init state

  def collect_charger_datum(self):
    charger_datum = self.charger.poll_data()
    self.check_communication_state(module=self.charger) # check write state
    self.data.append(charger_datum=charger_datum)       # append datum
    self.detail('%s\n' % charger_datum)                 # print charger datum when verbose
    return charger_datum

  # PTH commands
  def init_PTH(self):
    self.report('initializing PTH board ... ')
    self.PTH = PTH()                        # init PTH board
    self.check_communication_state(module=self.PTH) # check write state
    self.check_conf_state(conf_state.initialized,module=self.PTH)  # check PTH init state

  def on_rain(self):
    self.report('powering on rain monitor ... ')
    self.rain = Rain()
    self.PTH.on(module=self.rain)           # power on rain monitor module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_power_state(power_state.on,module=self.rain)   # check rain monitor power state

  def off_rain(self):
    self.report('powering off rain monitor ... ')
    self.PTH.off(module=self.rain)          # power off rain monitor module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_power_state(power_state.off,module=self.rain)  # check rain monitor init state

  def on_heater(self):
    self.report('powering on heater ... ')
    self.heater = Heater()                  # create object for heater module
    self.PTH.on(module=self.heater)         # power on heater module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_power_state(power_state.on,module=self.heater) # check heater power state

  def off_heater(self):
    self.report('powering off heater ... ')
    self.PTH.off(module=self.heater)         # power off heater module
    self.check_communication_state(module=self.PTH)  # check write state
    self.check_power_state(power_state.off,module=self.heater) # check heater power state

  def on_inverter(self):
    self.report('powering on inverter ... ')
    self.inverter = Inverter()                # create object for inverter module
    self.PTH.on(module=self.inverter)         # power on inverter module
    self.check_communication_state(module=self.PTH)   # check write state
    self.check_power_state(power_state.on,module=self.inverter) # check inverter power state

  def off_inverter(self):
    self.report('powering off inverter ... ')
    self.PTH.off(module=self.inverter)         # power off inverter module
    self.check_communication_state(module=self.PTH)    # check write state
    self.check_power_state(power_state.off,module=self.inverter) # check inverter power state

  def poll_rain(self):
    self.report('checking rain monitor ... ')
    self.PTH.poll_rain(module=self.rain)            # poll rain state
    self.check_communication_state(module=self.PTH) # check write state
    self.check_rain_state(module=self.rain)         # check rain state

  def collect_PTH_datum(self):
    PTH_datum = self.PTH.poll_data()
    self.check_communication_state(module=self.PTH) # check write state
    self.data.append(PTH_datum=PTH_datum)           # append datum
    self.detail('%s\n' % PTH_datum)                 # print PTH datum when verbose
    return PTH_datum

  # RPC commands
  def init_RPC(self):
    self.report('initializing RPC module ... ')
    self.RPC = RPC()                        # init RPC module
    self.check_conf_state(conf_state.initialized,module=self.RPC)  # check RPC init state

  def on_radiometer(self):
    self.report('powering on radiometer ... ')
    self.radiometer = Radiometer()                # create object for radiometer module
    self.RPC.on(module=self.radiometer)           # power on radiometer module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.on,module=self.radiometer)   # check radiometer power state

  def off_radiometer(self):
    self.report('powering off radiometer ... ')
    self.RPC.off(module=self.radiometer)           # power off radiometer module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.off,module=self.radiometer)   # check radiometer power state

  def on_shutter(self):
    self.report('opening shutter ... ')
    self.shutter = Shutter()                 # create object for shutter module
    self.RPC.on(module=self.shutter)         # power on shutter module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.on,module=self.shutter) # check shutter power state

  def off_shutter(self):
    self.report('closing shutter ... ')
    self.RPC.off(module=self.shutter)         # power off shutter module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.off,module=self.shutter) # check shutter power state

  def on_laser(self):
    self.report('  powering on laser ... ')
    self.laser = Laser()                   # create object for laser module
    self.RPC.on(module=self.laser)         # power on laser module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.on,module=self.laser) # check laser power state

  def off_laser(self):
    self.report('  powering off laser ... ')
    self.RPC.off(module=self.laser)         # power off laser
    self.check_communication_state(module=self.RPC) # check write state
    self.check_power_state(power_state.off,module=self.laser) # check laser power state

  # radiometer commands
  def init_radiometer(self):
    self.report('initializing radiometer ... ')
    self.radiometer.init()                         # init radiometer module
    self.check_communication_state(module=self.radiometer) # check write state
    self.check_conf_state(conf_state.initialized,module=self.radiometer)  # check radiometer conf state

  def read_radiometer_data(self,run_times=None):
    radiometer_datum = self.radiometer.read_data()
    self.check_communication_state(module=self.radiometer)
    self.data.append(radiometer_datum=radiometer_datum,run_times=run_times)

class Daemon(Control):
  '''
  5kmlas daemon process

  The daemon object interacts with the modules in a scripted manner.  When no
  operator object is present (in a second process), the daemon object will log
  PTH information infrequently.  When there is a second process containing an
  operator object, it will log PTH information frequently and commence the
  automated run sequence.
  '''

  def __init__(self,opts):
    super(Daemon,self).__init__(opts)             # daemon is a control module
    self.sleep_time = 5                           # run loop sleep [s]
    self.connected = False                        # connected to operator
    self.socket = Socket(side=socket_side.daemon) # IPC socket

  def __del__(self):
    self.phase = phase.final
    self.report('done running\n',color=self.GRAY)
    if self.connected:
      self.inform('daemon process unexpectedly disconnected\n',color=self.RED)
      self.connected = False
    '''
    since __del__ execution occurs when the python interpreter is
    self-destructing, we will hazard issuing these commands to the PTH board
    without checking whether they succeed or trigger any errors
    '''
    try : self.PTH.off(module=self.heater) # power off heater module
    except : pass
    try : self.PTH.off(module=self.rain)   # power off rain monitor
    except : pass

  def init(self):
    self.phase = phase.init
    self.init_data()    # init data structure
    self.init_charger() # init charger
    self.init_PTH()     # init PTH board
    self.on_rain()      # power on rain monitor
    self.poll_rain()    # check rain state
    #self.on_heater()    # power on window heater

  def run(self):
    '''
    datetime comparison epsilon needs to be less than the completion time of
    one loop, so that it doesn't trigger a conditional block again for the same
    event and timepoint in the next loop.  It also needs to be longer than the
    time it takes to complete all of the conditional blocks, so that a
    timepoint conditional is guaranteed to be true for all conditional blocks
    in the loop.  We set epsilon to be less than sleep time and ensure that
    sleep time - epsilon is longer than the time it takes to complete every
    conditional block within the following while loop.

    Each conditional tests whether the current time is within epsilon of a
    timepoint, where the timepoints are the divisions of a UTC day by the
    supplied timedelta.
    '''
    self.phase = phase.run
    self.report('running\n',color=self.GRAY)
    epsilon = timedelta(seconds=self.sleep_time-1)           # 1 s less than sleep time
    while True:
      now = datetime.now(utc)
      if self.socket.accept():                               # once every self.sleep_time s
        self.operator_communicate()
      if is_at_timepoint(now,timedelta(hours=2),epsilon):    # once every 2 h
        self.write_data()
      if is_at_timepoint(now,timedelta(minutes=15),epsilon): # once every 15 m
        self.collect_charger_datum()
        self.collect_PTH_datum()
      else:
        sleep(self.sleep_time)

  def final(self):
    self.phase = phase.final
    self.off_heater() # power off window heater
    self.off_rain()   # power off rain monitor

  def operator_communicate(self):
    signals,commands = self.read_socket() # read data from operator
    if signal.initialize in signals:      # operator is requesting to enter run mode
      self.report('connected to operator process\n')
      self.connected = True
      self.operator_init()
      self.operator_run()
      self.operator_final()
      self.write_socket('%d' % signal.finalize) # done
      self.connected = False
      self.report('disconnected from operator process\n')

  def operator_init(self):
    self.phase = phase.init
    self.poll_rain()       # check rain state before running
    self.on_inverter()     # power on inverter
    self.init_RPC()        # init RPC
    self.on_radiometer()   # power on radiometer
    self.init_radiometer() # init radiometer
    self.on_shutter()      # power on shutter

  def operator_run(self):
    self.phase = phase.run
    self.report('collecting data\n',color=self.GRAY)
    five_minutes = timedelta(seconds=10)
    now = self.start_time = datetime.now(utc)     # record laser on time
    self.on_laser()                               # power on laser
    while (now < self.start_time + five_minutes): # run for 5 m
      self.collect_charger_datum()
      self.collect_PTH_datum()
      sleep(5)                                    # collect charger,PTH data every 5 s
      now = datetime.now(utc)                     # new timestamp
    self.off_laser()                              # power off laser
    self.collect_charger_datum()                  # collect final charger datum
    self.collect_PTH_datum()                      # collect final PTH datum
    self.stop_time = datetime.now(utc)            # record laser off time
    self.report('done collecting\n',color=self.GRAY)

  def operator_final(self):
    self.phase = phase.final
    self.off_shutter()          # close shutter
    run_times = {'start':self.start_time,'stop':self.stop_time}
    self.read_radiometer_data(run_times) # read radiometer data and append run times
    self.write_data()           # write data
    self.off_radiometer()       # power off radiometer
    self.off_inverter()         # power off inverter
    # print all data when verbose
    self.detail('%s\n' % self.data)

class Operator(Control):
  '''
  operate 5kmlas system

  The Operator module instructs the Daemon module in another process to run the
  system.  Operator is a subclass of the Control module, which provides state
  checking and automatic shut down in case of error.  The operator object and
  daemon object perform a scripted conversation during the run phase.  This is
  necessary since the daemon process must be running constantly to monitor and
  log environment information, and the operator process is initiated by either
  Middle Drum or as part of a calibration run.
  '''

  def __init__(self,opts):
    super(Operator,self).__init__(opts)             # operator is a control module
    self.sleep_time = 0.5                           # seconds to wait between polling socket
    self.connected = False                          # connected to daemon
    self.socket = Socket(side=socket_side.operator) # IPC socket

  def daemon_communicate(self):
    self.write_socket('%d' % signal.initialize)
    self.connected = True
    while True:                             # from here on, daemon process is in control
      signals,commands = self.read_socket() # read data from daemon
      if signal.error in signals:           # daemon entered error mode
        self.verbosity = verbosity.verbose
      for command in commands:
        exec(command)                       # daemon sends python statements that will print status messages
      if signal.finalize in signals:        # daemon is done
        return                              # quit
      sleep(self.sleep_time)

# main #########################################################################

def parse_opts():
  '''
  handle invocation options and arguments
  '''
  usage = 'Usage: %prog [OPTIONS] MODE'
  description = 'Run 5 km laser calibration system.\nMODE is any of "operate" or "run" - Middle Drum operations [default], "calibrate" - calibrate 5kmlas, or "daemon" - run background helper process.'
  opt_parser = OptionParser(usage=usage,description=description,version='%prog-0.4')
  opt_parser.add_option('-c','--color',action='store_const',const=True,
      default=True,help='print messages in color [default]')

  verbose = OptionGroup(opt_parser,'Verbosity Options',
      'More quiet options take precedent over more verbose options when more than one is supplied.')
  verbose.add_option('-q','--quiet',action='store_const',const=True,
      default=False,help='print nothing except errors')
  verbose.add_option('-n','--normal',action='store_const',const=True,
      default=False,help='print normal operation messages and errors [default]')
  verbose.add_option('-v','--verbose',action='store_const',const=True,
      default=False,help='print data and serial commands and responses, normal messages, and errors')
  opt_parser.add_option_group(verbose)

  opts,args = opt_parser.parse_args()

  # handle tri-state verbosity option: prefer most quiet option supplied
  if opts.verbose and opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.verbose and opts.normal:
    opts.quiet = False
    opts.verbose = False
  elif opts.verbose and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  # default to normal output
  if not opts.verbose and not opts.normal and not opts.quiet:
    opts.normal = True

  # handle run mode argument, default mode is operate
  if len(args) == 0:
    args.append('operate')
  elif len(args) == 1:
    if args[0] == 'daemon' : pass
    elif args[0] == 'operate' : pass
    elif args[0] == 'run' : args[0] = 'operate'
    elif args[0] == 'calibrate' : pass
    else:
      opt_parser.print_usage()
      print opt_parser.expand_prog_name('%%prog: invalid MODE: %s.  Use "%%prog -h" for help.' % args[0])
      sys.exit(1)
  elif len(args) > 1:
    opt_parser.print_usage()
    print opt_parser.expand_prog_name('%prog: please specify only one MODE.  Use "%prog -h" for help.')
    sys.exit(1)

  return opts,args

def main():
  opts,args = parse_opts()

  if args[0] == 'daemon': # daemon mode
    daemon = Daemon(opts)
    daemon.init()
    daemon.run()
    daemon.final()
  elif args[0] == 'operate': # operation mode
    operator = Operator(opts)
    operator.daemon_communicate()
  elif args[0] == 'calibrate': # calibration mode
    calibrator = Operator(opts)
    calibrator.daemon_communicate()

if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    sys.exit(0)
  except OSError,oserror:
    print oserror
    sys.exit(1)
