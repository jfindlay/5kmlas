#!/usr/bin/env python
# 5kmlas_ctl - run 5 km laser calibration system
# Wed Feb 16 16:05:00 MST 2011
# findlay@cosmic.utah.edu

# TODO:
# - daemonize: move script to /usr/bin/5kmlas_ctl and create
#   /etc/init.d/5kmlas_ctl.  Allow for foreground connections to be made by
#   Middle Drum operators.  PTH init will occur on SBC bootup, retain a
#   persistent connection with the daemon, and will log environment and
#   battery data continuously.  The rest of the sequence will be controlled by
#   a simple `5kmlas_ctl run` command assisted by optparse.  Run data and non-
#   run PTH data will be batched onto the data USB storage and formatted into a
#   DST bank by a local cron job.  It will then be transferred to Middle Drum,
#   where it will be pooled into the  regular data collection and processing
#   streams as already implemented in Middle Drum operations.
# - if operator process fails, daemon process ensures modules shut down
#   gracefully
# - daemon process polls PTH periodically.  Polling interval is shorter while
#   operation or calibration process is running
# - need some kind of subprocess IPC setup to accomplish these goals
# - develop rigorous and thorough hardware failure simulation routine

# list of modules:
# - control
#   * data
#   * PTH
#     - rain
#     - heater
#     - inverter
#   * RPC
#     - radiometer
#     - shutter
#     - laser

import sys,re
from time import sleep
from datetime import datetime,timedelta
from optparse import OptionParser,OptionGroup
from serial import Serial,SerialException,SerialTimeoutException

class Enum:
  # this idiom is from http://norvig.com/python-iaq.html.  It might be better
  # to use collections.namedtuple, but this datatype wasn't added to python
  # until 2.6.  I could upgrade debian to squeeze, but I'm loth to stray too
  # far from Technologic Systems' 'officially' supported debian version
  '''
  Create an enumerated type, then add var/value pairs to it.
  The constructor and the method .ints(names) take a list of variable names,
  and assign them consecutive integers as values.  The method .strs(names)
  assigns each variable name to itself (that is variable 'v' has value 'v').
  The method .vals(a=99, b=200) allows you to assign any value to variables.
  A 'list of variable names' can also be a string, which will be .split().
  The method .end() returns one more than the maximum int value.

  Example: opcodes = Enum('add sub load store').vals(illegal=255).
  '''

  def __init__(self,names=[]) : self.ints(names)

  def set(self,var,val):
    '''Set var to the value val in the enum.'''
    if var in vars(self).keys() : raise AttributeError('duplicate var in enum')
    if val in vars(self).values() : raise ValueError('duplicate value in enum')
    vars(self)[var] = val
    return self

  def strs(self,names):
    '''Set each of the names to itself (as a string) in the enum.'''
    for var in self._parse(names) : self.set(var,var)
    return self

  def ints(self,names):
    '''Set each of the names to the next highest int in the enum.'''
    for var in self._parse(names) : self.set(var,self.end())
    return self

  def vals(self,**entries):
    '''Set each of var=val pairs in the enum.'''
    for (var,val) in entries.items() : self.set(var,val)
    return self

  def end(self):
    '''One more than the largest int value in the enum, or 0 if none.'''
    try : return max([x for x in vars(self).values() if type(x)==type(0)]) + 1
    except ValueError : return 0

  def _parse(self,names):
    ### If names is a string, parse it as a list of names.
    if type(names) == type('') : return names.split()
    else : return names

verbosity = Enum('quiet normal verbose') # message verbosity
phase = Enum('init run final')           # phase
# hardware states
power_state = Enum('undefined on off')
conf_state = Enum('undefined initialized finalized error')
rain_state = Enum('dry wet open')
# serial states
communication_state = Enum('success error timeout')
# FIFO IPC
direction = Enum('to_daemon from_daemon')
side = Enum('daemon operator calibrator')

class Data:
  def __init__(self):
    self.radiometer = []
    self.PTH = []
    zero_time = datetime.utcfromtimestamp(0)
    self.times = {'start':zero_time,'stop':zero_time}

  def append(self,*args,**kwargs):
    if 'radiometer_datum' in kwargs:
      self.radiometer.append(kwargs['radiometer_datum'])
    if 'PTH_datum' in kwargs:
      self.PTH.append(kwargs['PTH_datum'])
    if 'start' in kwargs:
      self.times['start'] = kwargs['start']
    if 'stop' in kwargs:
      self.times['stop'] = kwargs['stop']
  def write(self):
    pass
    # TODO:
    # load objects from DST.py and write data structure into DST file
    # the format of the DST file will be a heterogeneous stream with one part per UTC day
    # once data has been written to storage, clear all data from memory

# module abstract base classes #################################################

class SerialModule(Serial):
  '''
  abstract base class for serial modules

  This class provides error handling for initializing, reading, and writing
  serial devices.  If an exception is raised by pyserial, a serial module flag
  is set and then handled by the control module.
  '''

  def __init__(self,buffer_size,*args,**kwargs):
    self.serial_type = True # this is a serial module
    self.buffer_size = buffer_size
    try:
      super(SerialModule,self).__init__(*args,**kwargs)
    except SerialException,serial_exception:
      self.conf_state = conf_state.error
      self.message = 'failed to initialize %s serial connection: %s' % (self.name,serial_exception)
      return

  def read(self):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).read(self.buffer_size)
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to read from serial device %s: %s' % (self.name,serial_exception)
      return '' # classes derived from SerialModule always expect a return value of str type

  def write(self,data):
    try:
      self.communication_state = communication_state.success
      return super(SerialModule,self).write(data)
    except SerialException,serial_exception:
      self.communication_state = communication_state.error
      self.message = 'failed to write to serial device %s: %s' % (self.name,serial_exception)
      return
    except SerialTimeoutException,timeout_exception:
      self.communication_state = communication_state.timeout
      self.message = 'failed to write to serial device %s: %s' % (self.name,timeout_exception)
      return

class TestSerial(SerialModule):
  def __init__(self):
    self.name = 'test serial module'
    super(TestSerial,self).__init__(65536,'/dev/tts/0',baudrate=9600,timeout=0.5)

class PowerModule(object):
  '''
  abstract base class for power modules
  '''

  def __init__(self):
    self.power_type = True # this is a power module

# module classes ###############################################################

class PTH(SerialModule):
  '''
  PTH module

  ?|HELP                  - help
  AIN [B|C|D|E]           - read inputs as analog (V)
  AMON [B|C|D|E] [<th>]   - set analog input threshold (V)
  AUTO [<sec>]            - set automatic readout period - 0 disables
  ECHO [0|1]              - serial echo - 0=disable 1=enable
  HEAT [0|1]              - set SHT11 heater - 0=off 1=on
  HUMID                   - read humidity (%RH)
  IN [A|B|C|D|E]          - read inputs as digital (0|1)
  OUT [A|B|C|D|E] [0|1]   - read [set] isolated output
  PRESS                   - read pressure (kPa)
  RAIN                    - read rain sensor dry|wet|open (D|W|X)
  RMON [0|1]              - set rain monitor enable
  SUPPLY                  - read supply voltage (V)
  TEMP                    - read temperture (degK)
  TENAB [0|1]             - set thermostat enable - 0 disables
  THIGH [<temp>]          - set cooler set point (output D)
  TLOW [<temp>]           - set heater set point (output E)
  VER                     - read device firmware version
  '''

  def __init__(self,*args,**kwargs):
    self.buffer_size = 65536    # = 2**2**2**2 : termios read buffer size
    self.name = 'PTH board'     # PTH module name
    self.conf_message = ''      # state message
    self.message = ''           # result message
    super(PTH,self).__init__(self.buffer_size,'/dev/tts/0',baudrate=9600,timeout=0.5)
    self.write('ECHO 0\r\n') # disable PTH-side serial echo
    self.read()              # clear output buffer
    self.check_conf_state()

  def check_conf_state(self):
    self.write('VER\r\n')                         # check PTH initialized
    self.conf_message = self.read()[:-2]          # strip final '\r\n' characters from state message
    if re.search(r'VER\s+\S+',self.conf_message): # parse version message
      self.conf_state = conf_state.initialized    # module conf state
      self.message = 'PTH version: "%s"' % self.conf_message
    else:                                         # PTH did not print version message
      self.conf_state = conf_state.error
      self.message = 'PTH did not print version message.'
      self.message += '\nPTH output: "%s"' % self.conf_message

  def on(self,module=None): # close a PTH switch
    self.write('%s\r\n' % module.PTH_on_command) # close PTH switch for module
    module.PTH_message = self.read()[:-2]        # capture PTH message and strip final '\r\n'
    self.check_switch_state(module=module)       # check module power on
    if module.power_state == power_state.on:     # if module powered on
      sleep(module.power_on_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                        # module failed to power on
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_on_command

  def off(self,module=None): # open a PTH switch
    self.write('%s\r\n' % module.PTH_off_command) # open PTH switch for module
    module.PTH_message = self.read()[:-2]         # capture PTH message and strip final '\r\n'
    self.check_switch_state(module=module)        # check module power off
    if module.power_state == power_state.off:     # if module powered off
      sleep(module.power_off_sleep)               # wait for module to stabilize
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
    else:                                         # module failed to power off
      module.message = '%s is on PTH switch %s' % (module.name,module.PTH_switch)
      module.message += '\nPTH message: "%s"' % module.PTH_message
      module.message += '\nPTH message should be: "%s"' % module.PTH_off_command

  def check_switch_state(self,module=None):
    if re.search(r'%s' % module.PTH_on_command,module.PTH_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'%s' % module.PTH_off_command,module.PTH_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

  def poll_data(self):
    self.read() # clear output buffer
    self.write('PRESS\r\n')  ; press = self.read()
    self.write('TEMP\r\n')   ; temp = self.read()
    self.write('HUMID\r\n')  ; humid = self.read()
    self.write('RAIN\r\n')   ; rain = self.read()
    self.write('SUPPLY\r\n') ; supply = self.read()
    data_dict = {'timestamp':datetime.utcnow()}
    for measure in press,temp,humid,supply:
      if len(measure) != 0:
        # typical datum = ['PRESS','867.3']
        datum = re.split(r'\s+',measure)[:-1]
        if measure == rain:
          data_dict[rain_datum[0]] = rain_datum[1]
        else:
          data_dict[datum[0]] = float(datum[1])
    return data_dict

  def poll_rain(self,module=None):
    self.read() # clear output buffer
    self.write('RAIN\r\n')
    message = self.read()[:-2] # read rain state and trim final '\r\n'
    if len(message) != 0:
      module.PTH_message = message
      rain_datum = re.split(r'\s+',module.PTH_message)[:-1]
      if rain_datum[1] == 'D': # dry
        module.rain_state = rain_state.dry
        module.message = 'no rain: "%s"' % module.PTH_message
      if rain_datum[1] == 'W': # wet
        module.rain_state = rain_state.wet
        module.message = 'rain detected: "%s"' % module.PTH_message
      if rain_datum[1] == 'X': # open or no rain monitor
        module.rain_state = rain_state.open
        module.message = '%s open or no %s present: "%s"' % (module.name,module.name,module.PTH_message)

class Rain(PowerModule):
  '''rain module'''

  def __init__(self):
    self.name = 'rain monitor'               # heater module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'RMON'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 5                  # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Heater(PowerModule):
  '''heater module'''

  def __init__(self):
    self.name = 'window heater'              # heater module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'HEAT'                 # PTH board switch name
    self.PTH_on_command = '%s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = '%s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 30                 # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class Inverter(PowerModule):
  '''inverter module'''

  def __init__(self):
    self.name = 'power inverter'             # inverter module name
    self.power_state = power_state.undefined # module power state
    self.PTH_switch = 'A'                    # PTH board switch name
    self.PTH_on_command = 'OUT %s 1' % self.PTH_switch # PTH board on command
    self.PTH_off_command = 'OUT %s 0' % self.PTH_switch # PTH board off command
    self.power_on_sleep = 10                 # time to stabilize after power on
    self.power_off_sleep = 0                 # time to stabilize after power off
    self.PTH_message = ''                    # PTH message
    self.message = ''                        # result message

class RPC(SerialModule):
  '''
  RPC module

  RPC-2 Series
  (C) 1997 by BayTech
  F2.07

  Circuit Breaker: On

  1)...Outlet 1  : Off
  2)...Outlet 2  : Off
  3)...Outlet 3  : Off
  4)...Outlet 4  : Off
  5)...Outlet 5  : Off
  6)...Outlet 6  : Off
  '''

  def __init__(self):
    self.buffer_size = 65536 # = 2**2**2**2 : termios read buffer size
    self.name = 'RPC module' # RPC module name
    self.conf_message = ''   # state message
    self.message = ''        # result message
    super(RPC,self).__init__(self.buffer_size,'/dev/tts/1',baudrate=9600,timeout=1)
    self.check_conf_state()

  def check_conf_state(self):
    self.conf_message = self.read()             # init message
    if re.search(r'BayTech',self.conf_message): # parse message for 'BayTech' string
      self.conf_state = conf_state.initialized  # module conf state
      self.message = 'RPC initialized.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message
    else: # not a BayTech RPC, no RPC present, or if RPC prints out a message, the message doesn't contain 'BayTech'
      self.conf_state = conf_state.error
      self.message = 'RPC did not initialize.'
      self.message += '\nRPC message:\n"%s"' % self.conf_message

  def on(self,module=None): # power on a RPC outlet
    self.write('ON %d\r\n' % module.RPC_outlet)# power on RPC outlet for module
    sleep(0.5) ; self.write('Y\r\n')           # wait 0.5 s and confirm power on
    module.RPC_message = self.read()           # capture RPC message
    self.check_power_state(module=module)      # check powered on
    if module.power_state == power_state.on:   # if module powered on
      sleep(module.power_on_sleep)             # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                      # module failed to power on
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : On"' % (module.RPC_outlet,module.RPC_outlet)

  def off(self,module=None): # power off a RPC outlet
    self.write('OFF %d\r\n' % module.RPC_outlet) # power off RPC outlet for module
    sleep(0.5) ; self.write('Y\r\n')             # wait 0.5 s and confirm power off
    module.RPC_message = self.read()             # capture RPC message
    self.check_power_state(module=module)        # check powered off
    if module.power_state == power_state.off:    # if module powered off
      sleep(module.power_off_sleep)              # wait for module to stabilize
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"' % module.RPC_message
    else:                                        # module failed to power off
      module.message = '%s is on RPC outlet %s' % (module.name,module.RPC_outlet)
      module.message += '\nRPC message:\n"%s"\n' % module.RPC_message
      module.message += '\nRPC message should contain: "%d)...Outlet %d  : On"' % (module.RPC_outlet,module.RPC_outlet)

  def check_power_state(self,module=None):
    if re.search(r'^.*Outlet\s+%d\s+:\s+On.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.on
    elif re.search(r'^.*Outlet\s+%d\s+:\s+Off.*$' % module.RPC_outlet,module.RPC_message,re.M):
      module.power_state = power_state.off
    else:
      module.power_state = power_state.undefined

class Radiometer(SerialModule,PowerModule):
  '''
  radiometer module

  Auger CLF radiometer (RM-3700) settings from lwiencke:
  ID       Identity(3700)
  VR       Version
  TG 3     Trigger (0 internal, 3 external - positive edge)
  SS 0     Single shot (1 enable, 0 disable)
  FA 1.00  Calibration Factor Channel A - we use 1.00
  WA 335   Wavelength of laser(used to correct for Si probe response,)
  PA       Probe id and type (23 0 : 465 Si ), (2 0 : 734 pyro)
  EV 1     Event average       (should be 1)
  BS 0     In case this radiometer has batteries installed
  RA 4     Range  1,2,3:X,XX,XXX e-12 | 4,5,6:X,XX,XXX e-9 pJ
  ST       Return error status (should be 0)
  AD       ASCII Dump Mode
  '''

  def __init__(self): # software init
    self.name = 'radiometer'                 # radiometer module name
    self.power_state = power_state.undefined # power state
    self.conf_state = conf_state.undefined   # configuration state
    self.RPC_outlet = 1                      # RPC outlet number
    self.power_on_sleep = 0                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.conf_message = ''                   # state message
    self.message = ''                        # result message

  def init(self): # hardware init
    self.buffer_size = 65536          # = 2**2**2**2 : termios read buffer size
    # TODO: figure out how long the timeout needs to be to capture 5 m worth of radiometer data
    super(Radiometer,self).__init__(self.buffer_size,'/dev/tts/2',baudrate=9600,timeout=5)
    # the radiometer needs a timeout between consecutive commands
    sleep(0.5) ; self.write('TG 1\r') # internal trigger
    sleep(0.5) ; self.write('SS 0\r') # no single shot
    sleep(0.5) ; self.write('RA 2\r') # range 2: TODO: energy limits on this range?
    sleep(0.5) ; self.write('BS 0\r') # disable internal battery save
    #self.flushInput()
    #self.flushOutput()     # doesn't work when run from SBC
    self.read()             # clear output buffer
    self.check_conf_state()
    self.write('AD\r')      # ASCII dump

  def check_conf_state(self):
    self.write('ST\r')               # check error status
    self.conf_message = self.read()[:-1] # strip final '\r' characters from state message
    if re.search(r'0',self.message): # if no errors
      self.conf_state = conf_state.initialized
      self.message = 'radiometer returned error status "0", no error'
    else: # TODO: try to figure out how to get radiometer into 0 (no) error state
      #self.conf_state = conf_state.error
      self.conf_state = conf_state.initialized
      self.message = 'radiometer returned error status "%s"' % self.conf_message

  def read_data(self):
    energies = []
    for i in re.split(r'\s+',self.read()):
      try: # only return the numbers from the radiometer message
        energies.append(float(i))
      except:
        pass
    data_dict = {'timestamp':datetime.utcnow(),'energies':energies}
    return data_dict

class Shutter(PowerModule):
  '''shutter module'''

  def __init__(self):
    self.name = 'shutter'                    # shutter module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 3                      # RPC outlet number
    self.power_on_sleep = 10                 # time to wait after power on
    self.power_off_sleep = 10                # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

class Laser(PowerModule):
  '''laser module'''

  def __init__(self):
    self.name = 'laser'                      # laser module name
    self.power_state = power_state.undefined # power state
    self.RPC_outlet = 2                      # RPC outlet number
    self.power_on_sleep = 2                  # time to wait after power on
    self.power_off_sleep = 0                 # time to wait after power off
    self.RPC_message = ''                    # RPC message
    self.message = ''                        # result message

# control module ###############################################################

class Control(PowerModule):
  '''
  software control module for 5kmlas apparatus

  This control module wraps each function call of the other modules in order to
  simplify and unify error traps.  Each call sets one or more associated states
  in the module.  The control module will take action upon each setting of
  state: either proceed normally or try to return the hardware and software to
  a well-defined and safe state.

  This scheme assumes at least three things:
  - The python code and the operating system it runs on are either so much more
    reliable in comparison with the hardware that they aren't worth checking or
    they will provide their own error handling when necessary.
  - The firmware on the hardware is so much more reliable than the hardware
    itself that all problems will originate with a hardware failure or
    misconfiguration and that the firmware will report it.
  - The hardware modules will fail only at the time of a state change or a
    serial write
  If any of the serial devices (PTH,RPC,radiometer) fail on the negotiation of
  the serial connection or when any data is sent to them, pyserial will handle
  and report those errors and the control module will intercept those errors
  and shutdown as appropriate.

  The control process has three phases: init, run, and final.  Depending on the
  phase and module, the control module may fail in a different manner.
  '''

  def __init__(self,opts):
    # process invocation settings
    if opts.verbose:                     # verbose output
      self.verbosity = verbosity.verbose
    if opts.normal:                      # normal output
      self.verbosity = verbosity.normal
    if opts.quiet:                       # no output except errors
      self.verbosity = verbosity.quiet
    if opts.color:                       # colorful output
      self.color = opts.color

    self.setup_color()
    self.setup_modules()
    # TODO: connect to daemon process.  If it's not there, launch it?

  def setup_color(self):
    # modified from https://svn.blender.org/svnroot/bf-blender/trunk/blender/tools/bcolors.py
    if self.color == True:
      self.CYAN   = '\033[96m'
      self.VIOLET = '\033[95m'
      self.BLUE   = '\033[94m'
      self.YELLOW = '\033[93m'
      self.GREEN  = '\033[92m'
      self.RED    = '\033[91m'
      self.GRAY   = '\033[90m'
      self.ENDC   = '\033[0m'
    else: # no color
      self.CYAN   = ''
      self.VIOLET = ''
      self.BLUE   = ''
      self.YELLOW = ''
      self.GREEN  = ''
      self.RED    = ''
      self.GRAY   = ''
      self.ENDC   = ''

  def setup_modules(self):
    self.phase = phase.init # initial control phase
    self.data = Data()      # data structure
    # create submodule stubs
    self.PTH = None
    self.rain = None
    self.heater = None
    self.inverter = None
    self.RPC = None
    self.radiometer = None
    self.shutter = None
    self.laser = None
    # create list for modules that won't turn off
    self.modules_no_off = []

  def printf(self,data,color=None): # write to stdout
    if color : data = color + data + self.ENDC
    sys.stdout.write(data)
    sys.stdout.flush()

  def inform(self,data,color=None):
    '''
    write error information to sys.stdout even in quiet mode
    '''
    self.printf(self,data,color=color)

  def report(self,data,color=None):
    '''
    write normal-level information to sys.stdout
    '''
    if self.verbosity > verbosity.quiet:
      self.printf(self,data,color=color)

  def detail(self,data,color):
    '''
    write verbose-level information to sys.stdout
    '''
    if self.verbosity == verbosity.verbose:
    self.printf(self,data,color=color)

  # data command
  def write_data(self):
    self.report('writing data ... ')
    self.data.write() # format and save data, then clear data buffer
    self.report('done\n',color=self.GREEN)

  # PTH commands
  def init_PTH(self):
    self.report('initializing PTH board ... ')
    self.PTH = PTH()                        # init PTH board
    self.check_communication_state(module=self.PTH) # check write state
    self.check_init_state(module=self.PTH)  # check PTH init state

  def on_rain(self):
    self.report('powering on rain monitor ... ')
    self.rain = Rain()
    self.PTH.on(module=self.rain)           # power on rain monitor module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_on_state(module=self.rain)   # check rain monitor power state

  def off_rain(self):
    self.report('powering off rain monitor ... ')
    self.PTH.off(module=self.rain)          # power off rain monitor module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_off_state(module=self.rain)  # check rain monitor init state

  def on_heater(self):
    self.report('powering on heater ... ')
    self.heater = Heater()                  # create object for heater module
    self.PTH.on(module=self.heater)         # power on heater module
    self.check_communication_state(module=self.PTH) # check write state
    self.check_on_state(module=self.heater) # check heater power state

  def off_heater(self):
    self.report('powering off heater ... ')
    self.PTH.off(module=self.heater)         # power off heater module
    self.check_communication_state(module=self.PTH)  # check write state
    self.check_off_state(module=self.heater) # check heater power state

  def on_inverter(self):
    self.report('powering on inverter ... ')
    self.inverter = Inverter()                # create object for inverter module
    self.PTH.on(module=self.inverter)         # power on inverter module
    self.check_communication_state(module=self.PTH)   # check write state
    self.check_on_state(module=self.inverter) # check inverter power state

  def off_inverter(self):
    self.report('powering off inverter ... ')
    self.PTH.off(module=self.inverter)         # power off inverter module
    self.check_communication_state(module=self.PTH)    # check write state
    self.check_off_state(module=self.inverter) # check inverter power state

  def poll_rain(self):
    self.report('checking rain monitor ... ')
    self.PTH.poll_rain(module=self.rain)    # poll rain state
    self.check_communication_state(module=self.PTH) # check write state
    self.check_rain_state(module=self.rain) # check rain state

  def collect_PTH_datum(self):
    PTH_datum = self.PTH.poll_data()
    self.check_communication_state(module=self.PTH) # check write state
    self.data.append(PTH_datum=PTH_datum)   # append datum
    self.detail('%s\n' % PTH_datum) # print PTH datum when verbose

  # RPC commands
  def init_RPC(self):
    self.report('initializing RPC module ... ')
    self.RPC = RPC()                        # init RPC module
    self.check_init_state(module=self.RPC)  # check RPC init state

  def on_radiometer(self):
    self.report('powering on radiometer ... ')
    self.radiometer = Radiometer()                # create object for radiometer module
    self.RPC.on(module=self.radiometer)           # power on radiometer module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_on_state(module=self.radiometer)   # check radiometer power state

  def off_radiometer(self):
    self.report('powering off radiometer ... ')
    self.RPC.off(module=self.radiometer)           # power off radiometer module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_off_state(module=self.radiometer)   # check radiometer power state

  def on_shutter(self):
    self.report('opening shutter ... ')
    self.shutter = Shutter()                 # create object for shutter module
    self.RPC.on(module=self.shutter)         # power on shutter module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_on_state(module=self.shutter) # check shutter power state

  def off_shutter(self):
    self.report('closing shutter ... ')
    self.RPC.off(module=self.shutter)         # power off shutter module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_off_state(module=self.shutter) # check shutter power state

  def on_laser(self):
    self.report('  powering on laser ... ')
    self.laser = Laser()                   # create object for laser module
    self.RPC.on(module=self.laser)         # power on laser module
    self.check_communication_state(module=self.RPC) # check write state
    self.check_on_state(module=self.laser) # check laser power state

  def off_laser(self):
    self.report('  powering off laser ... ')
    self.RPC.off(module=self.laser)         # power off laser
    self.check_communication_state(module=self.RPC) # check write state
    self.check_off_state(module=self.laser) # check laser power state

  # radiometer commands
  def init_radiometer(self):
    self.report('initializing radiometer ... ')
    self.radiometer.init()                         # init radiometer module
    self.check_communication_state(module=self.radiometer) # check write state
    self.check_init_state(module=self.radiometer)  # check radiometer conf state

  def read_radiometer_data(self):
    radiometer_datum = self.radiometer.read_data()
    self.check_communication_state(module=self.radiometer)
    self.data.append(radiometer_datum=radiometer_datum)

  # state checks
  def check_init_state(self,module=None):
    if module.conf_state == conf_state.initialized:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    elif module.conf_state == conf_state.undefined or module.conf_state == conf_state.finalized:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown()
    elif module.conf_state == conf_state.error:
      self.inform('error\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown()

  def check_final_state(self,module=None):
    if module.conf_state == conf_state.finalized:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    elif module.conf_state == conf_state.undefined or module.conf_state == conf_state.initialized:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown(module_no_off=module)
    elif module.conf_state == conf_state.error:
      self.inform('error\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown(module_no_off=module)

  def check_on_state(self,module=None):
    if module.power_state == power_state.on:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    elif module.power_state == power_state.undefined or module.power_state == power_state.off:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown()

  def check_off_state(self,module=None):
    if module.power_state == power_state.off:
      self.report('done\n',color=self.GREEN)
      self.detail('%s\n' % module.message)
    elif module.power_state == power_state.undefined or module.power_state == power_state.on:
      self.inform('failed\n',color=self.RED)
      self.inform('%s\n' % module.message)
      self.emergency_shutdown(module_no_off=module)

  def check_rain_state(self,module=None):
    if module.rain_state == rain_state.dry:
        self.report('dry\n',color=self.GRAY)
        self.detail('%s\n' % module.message)
    elif module.rain_state == rain_state.wet:
      self.report('wet\n',color=self.BLUE)
      self.report('%s\n' % module.message)
      if self.phase != phase.final:
        self.emergency_shutdown()
    elif module.rain_state == rain_state.open:
      self.report('open\n',color=self.YELLOW)
      self.report('%s\n' % module.message)
      if self.phase != phase.final:
        #self.emergency_shutdown() # TODO: get rain sensor
        pass

  def check_communication_state(self,module=None):
    if module.communication_state == communication_state.success:
      pass # serial module successfully written to or read from
    elif module.communication_state == communication_state.error:
      self.emergency_shutdown()
    elif module.communication_state == communication_state.timeout:
      self.emergency_shutdown()

  def emergency_shutdown(self,module_no_off=None):
    '''
    To avoid an open loop, we will not try to final or power off any module
    that won't do so.
    '''
    self.modules_no_off.append(module_no_off)
    self.verbosity = verbosity.verbose
    self.inform('\nshutting down 5kmlas\n')
    # if laser module exists and isn't the module that won't turn off
    if self.laser and not self.laser in self.modules_no_off:
      if self.laser.power_state == power_state.on:
        self.off_laser()
        self.read_radiometer_data() # if the laser is on, then there may be some data
        self.data.write()           # try to save whatever data we have
    if self.shutter and not self.shutter in self.modules_no_off:
      if self.shutter.power_state == power_state.on:
        self.off_shutter()
    if self.radiometer and not self.radiometer in self.modules_no_off:
      if self.radiometer.power_state == power_state.on:
        self.off_radiometer()
    if self.inverter and not self.inverter in self.modules_no_off:
      if self.inverter.power_state == power_state.on:
        self.off_inverter()
    if self.heater and not self.heater in self.modules_no_off:
      if self.heater.power_state == power_state.on:
        self.off_heater()
    if self.rain and not self.rain in self.modules_no_off:
      if self.rain.power_state == power_state.on:
        self.off_rain()
    # TODO: perhaps set a flag on the SBC to not run again if there is a problem
    sys.exit(1) # system should now be in as safe of a state as possible

# operation classes ############################################################

class FIFO:
  '''
  setup posix fifo-based IPC between the daemon process and an operator process
  or a calibrator process

  There should never be more than one Operator class instance (operator or
  calibrator object) at any time.

  All communications from the operator and calibrator objects to the PTH board
  pass through the IPC fifos.
  '''
  def __init__(self,direction=None,side=None):
    self.buffer_size = 65536 # = 2**2**2**2
    # fifo direction: from operator or calibrator to daemon or from daemon to operator or calibrator
    if direction == direction.to_daemon:
      self.name = '/tmp/5kmlas_to_daemon'
      os.mkfifo(self.name)   # create to-daemon fifo
      if side == side.daemon:
        options = os.O_NDELAY|os.O_RDONLY
      elif side == side.operator or side == side.calibrator:
        options = os.O_NDELAY|os.O_WRONLY
    elif direction == direction.from_deamon:
      self.name = '/tmp/5kmlas_from_daemon'
      os.mkfifo(self.name)   # create from-daemon fifo
      if side == side.daemon:
        options = os.O_NDELAY|os.O_WRONLY
      elif side == side.operator or side == side.calibrator:
        options = os.O_NDELAY|os.O_RDONLY
    self.fd = os.open(self.name,options)

  def __del__(self):
    os.close(self.fd)      # close file descriptor
    if os.path.exists(self.name):
      os.remove(self.name) # delete fifo

class Daemon:
  '''
  5kmlas daemon process

  Like the operator object, the daemon object interacts with the control module
  in a scripted manner.  Its jobs are to log PTH information and write all
  data.  When no operator object is present (in a second process), the daemon
  object will log PTH information infrequently.  When there is a second process
  containing an operator object, it will log PTH information frequently.
  '''

  def __init__(self,opts):
    self.control = Control(opts) # control module
    self.disconnected_sleep = 5  # run loop sleep when not connected to an operator process
    self.fifo_to_daemon = FIFO(direction='to daemon')     # create inbound fifo
    self.fifo_from_daemon = FIFO(direction='from daemon') # create outbound fifo

  def init(self):
    self.control.phase = phase.init
    self.control.init_PTH()        # init PTH board
    self.control.on_rain()         # power on rain monitor
    self.control.poll_rain()       # check rain state
    self.control.on_heater()       # power on window heater

  def run(self):
    while (True):
      sleep(2)
      data = self.read_fifo_to_daemon()
      if len(data) > 0:
        print data

  def read_fifo_to_daemon(self):
    try:
      data = os.read(self.fifo_to_daemon.fd,self.buffer_size)
    except OSError:
      data = '' # only read from fifo if there's data in it
    return data

  def run(self):
    self.control.phase = phase.run
    self.control.report('collecting data\n',color=self.control.GRAY)
    sleep_time = self.disconnected_sleep # wait longer between PTH data polls when disconnected
    two_hours = timedelta(hours=2)
    now = start_time = datetime.utcnow()
    while (True):
      elapsed = now + start_time
      if elapsed >= two_hours:
        now = start_time = datetime.utcnow()
        self.control.write_data()                  # write data once every 2 hours
      if abs(elapsed/five_mintues.minutes - timedelta(seconds=5)) # TODO: figure this out

  def run(self):
    self.control.phase = phase.run
    self.control.report('collecting data\n',color=self.control.GRAY)
    sleep_time = self.disconnected_sleep # wait longer between PTH data polls when disconnected
    while (True):
      while (now < self.start_time + two_hours): # collect data for 2 hours
        self.control.collect_PTH_datum()         # collect PTH data about every 5 minutes
        self.control.detail('%s\n' % PTH_datum)  # print PTH datum when verbose
        self.operator.stdin.write(PTH_datum)     # TODO: tell operator PTH data so it can print it out
        five_minutes = timedelta(minutes=5)
        sleep(five_minutes.seconds)              # sleep for 5 minutes
        now = datetime.utcnow()
      # this process should never end under normal circumstances
      self.control.report('done collecting\n',color=self.control.GRAY)

  # TODO: figure out how to gracefully end daemon from command line
  def final(self):
    self.control.phase = phase.final
    self.control.off_heater() # power off window heater
    self.control.off_rain()   # power off rain monitor

class Operator:
  '''
  operate 5kmlas system

  The control module object provides a high-level interface to each of the
  physical serial and power modules, handles errors, and automatically shuts
  the modules down intelligently in the case of error.  The operator class
  provides the recipie for operation, like a person operating a control panel
  with a checklist.
  '''

  def __init__(self,opts):
    self.control = Control(opts) # control module

  def init(self):
    self.control.phase = phase.init
    # TODO: connect to daemon
    self.control.on_inverter()     # power on inverter
    self.control.init_RPC()        # init RPC
    self.control.on_radiometer()   # power on radiometer
    self.control.init_radiometer() # init radiometer
    self.control.on_shutter()      # power on shutter

  def run(self):
    self.control.phase = phase.run
    self.control.report('collecting data\n',color=self.control.GRAY)
    five_minutes = timedelta(seconds=10)
    now = self.start_time = datetime.utcnow()     # record laser on time
    self.control.on_laser()                       # power on laser
    while (now < self.start_time + five_minutes): # run for 5 minutes
      sleep(1) ; now = datetime.utcnow()
    self.control.off_laser()                      # power off laser
    self.stop_time = datetime.utcnow()            # record laser off time
    self.control.report('done collecting\n',color=self.control.GRAY)

  def final(self):
    self.control.phase = phase.final
    self.control.off_shutter()                      # close shutter
    self.daemon.control.read_radiometer_data()      # TODO: read radiometer data
    self.daemon.control.data.append(start=self.start_time,stop=self.stop_time) # TODO: collect run times
    self.daemon.control.write_data()                # TODO: write data
    self.control.off_radiometer()                   # power off radiometer
    self.control.off_inverter()                     # power off inverter
    # print all data when verbose
    self.control.detail('%s\n' % self.control.data.radiometer)
    self.control.detail('%s\n' % self.control.data.PTH)
    self.control.detail('%s\n' % self.control.data.times)

# main #########################################################################

def parse_opts():
  '''
  handle invocation options and arguments
  '''
  opt_parser = OptionParser(description='Run 5 km laser calibration system.',version='%prog-0.3')
  opt_parser.add_option('-m','--mode',default='operate',type=str,
      help='"operate"   - Middle Drum operations [default], '
      '"calibrate" - 5kmlas calibration,              '
      '"daemon"    - run background helper process')
  opt_parser.add_option('-c','--color',action='store_const',const=True,
      default=True,help='print messages in color [default]')
  # TODO:
  # - make a 'run' option that is a synonym to 'operate'
  # - make 'mode' option a positional argument

  verbose = OptionGroup(opt_parser,'Verbosity Options',
      'More quiet options take precedent over more verbose options when more than one is supplied.')
  verbose.add_option('-q','--quiet',action='store_const',const=True,
      default=False,help='print nothing except errors')
  verbose.add_option('-n','--normal',action='store_const',const=True,
      default=False,help='print normal operation messages [default] and errors')
  verbose.add_option('-v','--verbose',action='store_const',const=True,
      default=False,help='print data and serial commands and responses, normal messages, and errors')
  opt_parser.add_option_group(verbose)

  opts,args = opt_parser.parse_args()

  # handle tri-state verbosity option: prefer most quiet option supplied
  if opts.verbose and opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.verbose and opts.normal:
    opts.quiet = False
    opts.verbose = False
  elif opts.verbose and opts.quiet:
    opts.normal = False
    opts.verbose = False
  elif opts.normal and opts.quiet:
    opts.normal = False
    opts.verbose = False
  # default to normal output
  if not opts.verbose and not opts.normal and not opts.quiet:
    opts.normal = True

  return opts,args

def main():
  opts,args = parse_opts()

  if opts.mode == 'daemon': # daemon mode
    daemon = Daemon(opts)
    daemon.init()
    daemon.run()
  if opts.mode == 'operate': # operation mode
    operator = Operator(opts)
    operator.init()
    operator.run()
    operator.final()
  if opts.mode == 'calibrate': # calibration mode
    calibrator = Operator(opts)
    calibrator.init()
    calibrator.run()
    calibrator.final()

if __name__ == '__main__' : main()
